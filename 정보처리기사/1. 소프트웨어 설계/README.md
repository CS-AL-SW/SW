# 1. 소프트웨어 공학의 개념

## **소프트웨어**

**소프트웨어(SW)의 개념**

- 컴퓨터를 동작시키고 어떤 일의 처리 순서와 방법을 지시하는 명령어의 집합인 프로그램과 프로그램의 수행에 필요한 절차, 규칙, 관련 문서 등을 총칭한다.
- 프로그램(Program) : 컴퓨터를 통해 일련의 작업을 처리하기 위한 명령어와 관련된 데이터의 집합을 의미한다.
- 자료 구조(Data Structure): 컴퓨터 기억 장치 내에 자료의 표현, 처리, 저장 방법 등을 총칭하는 것으로 데이터 간의 논리적 관계나 처리 알고리즘을 의미한다.
- 문서(Paper) : 소프트웨어를 개발함에 있어서 사용자 설명서, 소프트웨어 요구분석서, 평가서, 명세서, 프로젝트 계획서, 검사 계획서 등을 의미한다.

**소프트웨어의 특징**

- 상품성 : 소프트웨어를 개발하면 상품이 되어 판매가 된다.
- 복잡성 : 개발하는 과정이 복잡하고 관리가 어렵다.
- 변경 가능성 : 프로그램을 일부 수정하여 업그레이드 및 오류 수정 등을 할 수 있다.
- 복제성 : 복제가 용이해 쉽게 복사, 유통이 가능하다.

**시스템(System)의 개요와 기본 요소**

- 시스템의 개요
  - 컴퓨터로 처리 가능한 자료를 입력하고 저장, 처리, 가공해 출력할 수 있도록 설계/구현된 정보 체계를 의미한다.
  - 하나의 목적을 위해 다양한 요소가 유기적으로 결합된 것을 의미한다.
- 기본 요소
  - 입력, 처리, 출력, 제어, 피드백으로 구성된다.

**소프트웨어 위기(Software Crisis)**

- 컴퓨터의 발달 과정에서 소프트웨어의 개발 속도가 하드웨어의 개발 속도를 따라가지 못해 사용자들의 요구사항을 감당할 수 없는 문제가 발생함을 의미한다.
- 소프트웨어 위기의 원인
  - 하드웨어 비용을 초과하는 개발 비용의 증가
  - 개발 기간의 지연
  - 개발 인력 부족 및 인건비 상승
  - 성능 및 신뢰성 부족
  - 유지보수의 어려움에 따른 엄청난 비용

## **소프트웨어 공학(Software Engineering)**

**소프트웨어 공학의 이해**

- 경제적으로 신뢰도 높은 소프트웨어를 만들기 위한 방법, 도구와 절차들의 체계를 말한다.
- IEEEE(전기/전자기술협회)는 소프트웨어의 개발, 운용, 유지보수 및 파기에 대한 체계적인 접근 방법이라 정의하였다.

**소프트웨어 공학의 기본 원칙**

- 현대적인 프로그래밍 기술을 적용해야 한다.
- 신뢰성이 높아야 한다.
- 사용의 편리성과 유지보수성이 높아야 한다.
- 지속적인 검증 시행을 해야 한다.

**소프트웨어 공학 계층 구조**

- 도구 : 프로세스와 방법을 처리하는 기능을 제공하는 것이다.
- 방법론 : 소프트웨어를 설계하는데 기술적인 방법을 제공하는 것이다.
- 프로세스 : 소프트웨어의 가장 기초가 되며 개발에 사용되는 방법론과 도구가 적용되는 순서를 의미한다.

**소프트웨어 품질**

- 사용자의 요구대로 만들어져야 한다.
- 유지보수가 쉬워야 한다.
- 에러를 최소화해야 한다.
- 초반에 정한 비용에 맞춰 개발해야 한다.
- 정확한 결과가 도출되어야 한다.
- 원하는 시간에 원하는 기능을 수행할 수 있어야 한다.

**소프트웨어 공학의 목표**

- 소프트웨어의 생산성과 품질을 향상시킨다.
- 최소의 비용으로 단기간에 시스템에 적합한 소프트웨어를 개발하는 것이 소프트웨어 공학의 궁극적 목적이다.

# 2. 재공학

## **재공학**

**소프트웨어 재공학(Software Reengineering)의 개념**

- 소프트웨어 위기를 개발의 생산성이 아닌 유지보수의 생산성으로 해결하려는 방법을 의미한다.
- 현재의 시스템을 변경하거나 재구조화(Restructuring)하는 것이다.
- 재구조화는 재공학의 한 유형으로 사용자의 요구사항이나 기술적 설계의 변경 없이 프로그램을 개선하는 것이다.
- 소프트웨어 재공학 관점에서 가장 연관 깊은 유지보수 유형은 예방 유지보수(Preventive Maintenance)이다.

**재공학의 장점, 목표, 과정**

장점

- 개발 시간 및 비용 감소
- 품질 향상
- 생산성 향상
- 신뢰성 향상
- 구축 방법에 대한 지식의 공유
- 프로젝트 실패 위험 감소

목표

- 소프트웨어의 유지보수성 향상이 최우선
- 복잡한 시스템을 다루는 방법 구현, 다른 뷰의 생성, 잃어버린 정보의 복구 및 제거
- 재사용을 수월하게 하며 소프트웨어의 수명을 연장하기 위함.

과정

- 분석(Analysis) => 구성(Restructuring) => 역공학(Reverse Engineering) => 이식(Migration)

## **역공학**

**역공학의 개념**

- 소프트웨어를 분석하여 소프트웨어 개발 과정과 데이터 처리 과정을 설명하는 분석 및 설계 정보를 재발견하거나 다시 만들어내는 작업이다.
- 역공학의 가장 간단하고 오래된 형태는 재문서화라고 할 수 있다.

## **CASE(Computer Aided Software Engineering)**

**CASE**

- 소프트웨어 개발 과정에서 사용되는 요구분석, 설계, 구현, 검사 및 디버깅 과정을 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 작업이다.
- 자료 흐름도 등의 다이어그램을 쉽게 작성하게 해주는 소프트웨어 CASE 도구이다.
- 작업 과정 및 데이터 공유를 통해 작업자 간의 커뮤니케이션을 증대한다.

**CASE가 제공하는 기능**

- 개발을 신속하게 할 수 있고, 오류 수정이 쉬워 소프트웨어 품질이 향상된다.
- 소프트웨어 생명주기의 전체 단계를 연결해 주고 자동화시켜 주는 통합된 도구를 제공해주는 기술이다.
- 소프트웨어 시스템의 문서화 및 명세화를 위한 그래픽 기능을 제공한다.
- 소프트웨어 개발 단계의 표준화를 기할 수 있으며, 자료 흐름도 작성 기능을 제공한다.
- 모델들 사이의 모순 검사 기능을 제공하며 다양한 소프트웨어 개발 모형을 지원한다.
- 원천 기술 : 구조적 기법, 프로토타이핑 기술, 정보 저장소 기술

**CASE 사용의 장점**

- 소프트웨어 개발 기간 단축 및 개발 비용을 절약하여 소프트웨어 생산성을 향상시킨다.
- 자동화된 검사를 통해 소프트웨어 품질이 향상된다.
- 프로그램의 유지보수가 간편해지고 소프트웨어 모듈의 재사용성이 향상된다.
- 소프트웨어 개발 주기의 표준안 확입, 소프트웨어 개발 기법의 실용화, 문서화의 용이성 제공, 시스템 수정 및 유지보수 축소 등의 효과를 얻을 수 있다.

**CASE의 분류**

- 상위(Upper) CASE : 요구분석 및 설계 단계 지원
- 하위(Lower) CASE : 소스 코드 작성, 테스트, 문서화 과정 지원
- 통합(Integrate) CASE : 소프트웨어 개발 주기 전체 과정 지원

## **요구사항 분석을 위한 CASE 도구**

**요구사항 분석을 위한 CASE**

- 요구사항을 자동으로 분석하고, 요구사항 분석 명세서를 기술하도록 개발된 도구를 의미한다.
- 표준화와 보고를 통한 문서화 품질 개선, 변경이 주는 영향 추적의 용이성, 명세에 대한 유지보수 비용 축소, 교차 참조도와 보고서를 통한 결함, 생략, 불일치 등의 발견 용이성 등의 특징을 갖는다.
- DB가 모두에게 이용 가능하다는 점에서 분석자들 간의 적절한 조정 기능을 제공한다.

**요구사항 분석을 위한 CASE 도구**

- SADT(Structured Analysis and Design Technique) : SoftTech 사에서 개발한 것으로 시스템 정의, 소프트웨어 요구사항 분석, 시스템/소프트웨어 설계를 위해 널리 이용되어 온 구조적 분석 및 설계 도구이다. 구조적 요구분석을 하기 위해 블록 다이어그램을 채택한 자동화 도구다.
- REM(Software Requirements Engineering Methodolohy) = RSL/REVS : TRW 사가 우주 국방 시스템 그룹에 의해 실시간 처리 소프트웨어 시스템에서 요구사항을 명확히 기술하도록 할 목적으로 개발한 것으로, RSL과 REVS를 사용하는 자동화 도구이다.
  - RSL(Requirement Statement Language) : 요소, 속성, 관계, 구조들을 기술하는 요구사항 기술 언어이다.
  - REVS(Requirement Engineering and Validation System) : RSL로 기술된 요구사항들을 자동으로 분석하여 요구사항 분석 명세서를 출력하는 요구사항 분석기이다.

# 3. 소프트웨어 개발 방법론

## **소프트웨어 설계 방법론**

**소프트웨어 생명주기(Software Life Cycle)**

- 소프트웨어 제품의 개념 형성에서 시작하여 운용/유지보수에 이르기까지 변화의 모든 과정이다.
- 타당성 검토 => 개발 계획 => 요구사항 분석 => 설계 => 구현 => 테스트 => 운용 => 유지보수

**폭포수 모형(Waterfall Model)의 개요**

- 선형 순차적 모델이라고도 하며 Boehm이 제시한 고전적 생명주기 모형으로, 소프트웨어 개발 과정의 각 단계가 순차적으로 진행되는 모형이다.

**나선형 모형(Spiral Model)**

- Boehm이 제시하였으며, 반복적인 작업을 수행하는 점증적 생명주기 모형이다.
- 점증적 모형, 집중적 모형이라고도 하며 유지보수 과정이 필요 없다.
- 소프트웨어 개발 중 발생할 수 있는 위험을 관리하고 최소화하는 것이 목적이다.
- 나선을 따라서 돌아가면서 각 개발 순서를 반복하여 수행하는 점진적 방식으로 누락된 요구사항을 추가할 수 있다.

**하향식과 상향식 설계**

- 하향식 설계 : 소프트웨어 설계 시 제일 상위에 있는 Main User Function에서 시작하여 기능을 하위 기능들로 나눠 가면서 설계하는 방식이다.
- 상향식 설계 : 가장 기본적인 컴포넌트를 먼저 설계한 다음 이것을 사용하는 상위 수준의 컴포넌트를 설계하는 방식이다.

**프로토타입 모형(Prototype Model)의 개요**

- 실제 개발될 시스템의 견본(Prototype)을 미리 만들어 최종 결과물을 예측하는 모형이다.
- 개발이 완료되고 나서 사용을 하면 문제점을 알 수 있는 폭포수 모형의 단점을 보완하기 위한 모형으로 요구사항을 충실히 반영할 수 있다.

**HIPO(Hierarchy Input Process Output)**

- 입력, 처리, 출력으로 구성되는 시스템 분석 및 설계와 시스템 문서화용 기법이다.
- 일반적으로 가시적 도표(Visual Table of Contents), 총체적 다이어그램(Overview Diagram), 세부적 다이어그램(Detail Diagram)으로 구성된다.
- 구조도(가시적 도표, Visual Table of Contents), 개요, 도표(Index Diagram), 상세 도표(Detail Diagram)로 구성된다.
- 가시적 도표는 전체적인 기능과 흐름을 보여주는 구조이다.
- 기능과 자료의 의존 관계를 동시에 표현할 수 있다.
- 보기 쉽고 이해하기 쉬우며 유지보수가 쉽다.
- 하향식 소프트웨어 개발을 위한 문서화 도구이다.

**V-모델**

- 폭포수 모형에 시스템 검증과 테스트 작업을 강조한 모델이다.
- 세부적인 프로세스로 구성되어 있어서 신뢰도 높은 시스템 개발에 효과적이다.
- 개발 단계의 작업을 확인하기 위해 테스트 작업을 수행한다.
- 생명주기 초반부터 테스트 작업을 지원한다.
- 코드뿐만 아니라 요구사항과 설계 결과도 테스트할 수 있어야 한다.
- 폭포수 모형보다 반복과 재처리 과정이 명확하다.
- 테스트 작업을 단계별로 구분하므로 책임이 명확해진다.

## **애자일(Agile) 개발 방법론**

**애자일(Agile) 개발방법론**

- 날렵한, 재빠른 이란 사전적 의미가 있다.
- 특정 방법론이 아닌 소프트웨어를 빠르고 낭비 없이 제작하기 위해 고객과의 협업에 초점을 두고 소프트웨어 개발 중 설계 변경에 신속히 대응하여 요구사항을 수용할 수 있다.
- 절차와 도구보다 개인과 소통을 중요시하고 고객과의 피드백을 중요하게 생각한다.
- 소프트웨어가 잘 실행되는데 가치를 두며, 소프트웨어 배포 시차를 최소화할 수 있다.
  - 특징 : 짧은 릴리즈와 반복, 점증적 설계, 사용자 참여, 문서 최소화, 비공식적인 커뮤니케이션 변화
  - 종류
    - 익스트림 프로그래밍(XP, eXtreame Programming)
    - 스크럼(SCRUM)
    - 린(Lean)
    - DSDM(Dynamic System Development Method, 동적 시스템 개발 방법론)
    - FDD(Feature Driven Development, 기능 중심 개발)
    - Crystal
    - ASD(Adaptive Software Development, 적응형 소프트웨어 개발방법론)
    - DAD(Disciplined Agile Delivery, 학습 애자일 배포)

**Ahile 선언문**

- 프로세스나 도구보다 개인과의 소통이 더 중요하다.
- 완벽한 문서보다 실행되는 소프트웨어가 더 중요하다.
- 계약 협상보다 고객과의 협업이 더 중요하다.
- 계획을 따르는 것보다 변경에 대한 응답이 더 중요하다.

## **XP(eXtreme Programming)**

**XP(eXtreme Programming)**

- 1999년 Kent Beck이 제안하였으며, 개발 단계 중 요구사항이 시시각각 변동이 심한 경우 적합한 방법론이다.
- 요구에 맞는 양질의 소프트웨어를 신속하게 제공하는 것을 목표로 한다.
- 요구사항을 모두 정의해 놓고 작업을 진행하는 것이 아니라, 요구사항이 변경되는 것을 적용하는 방식으로 예측성보다는 적응성에 더 높은 가치를 부여한 방법이다.
- 고객의 참여와 개발 과정의 반복을 극대화하여 생산성을 향상하는 방법이다.

**XP 핵심 가치**

- 소통(Communication) : 개발자, 관리자, 고객 간의 원활한 소통을 지향한다.
- 단순성(Simplicity) : 부가적 기능 또는 미사용 구조와 알고리즘은 배제한다.
- Feedback : 소프트웨어 개발에서 변화는 불가피하다. 이러한 변화는 지속적 테스트와 통합, 반복적 결함 수정 등 빠르게 피드백한다.
- 용기(Courage) : 고객 요구사항 변화에 능동적으로 대응한다.
- 존중(Respect) : 개발 팀원 간의 상호 존중을 기본으로 한다.

**XP Process**

| 용어             | 설명                                                                                                                                                                                                                                                                                                              |
| ---------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| User Story       | 일종의 요구사항으로 UML의 유즈케이스와 같은 목적으로 생성되나, 형식이 없고 고객에 의해 작성된다는 것이 다르다.                                                                                                                                                                                                    |
| Release Planning | 몇 개의 스토리가 적용되어 부분적으로 기능이 완료된 제품을 제공하는 것으로 부분/전체 개발 완료 시점에 대한 일정을 수립한다.                                                                                                                                                                                        |
| iteration        | 하나의 릴리즈를 세분화한 단위이며 1~3주 단위로 진행된다. 반복(iteration) 진행 중 새로운 스토리가 추가될 때 진행 중 반복(Iteration)이나 다음 반복에 추가될 수 있다.                                                                                                                                                |
| Acceptance Test  | 릴리즈 단위의 개발이 구현되었을 때 진행하는 테스트로, 사용자 스토리에 작성된 요구사항을 확인하여 고객이 직접 테스트한다.<br>오류가 발견되면 다음 반복(Iteration)에 추가한다. 테스트 후 고객의 요구사항이 변경되거나 추가되면 중요도에 따라 우선순위가 변경될 수 있다.<br>완료 후 다음 반복(Iteration)을 진행한다. |
| Small Release    | 릴리즈 단위를 기능별로 세분화하면 고객의 반응을 기능별로 확인할 수 있다.<br>최종 완제품일 때 고객에 의한 최종 테스트 진행 후 고객에 제공한다.                                                                                                                                                                     |

**XP의 12가지 실천사항(Practice)**

| 구분                 | 12 실천사항                    | 설명                                                                                                                                                                                                             |
| -------------------- | ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Fine Scale Feed-back | Pair Programing(짝 프로그래밍) | 두 사람이 짝이 되어 한 사람은 코딩을, 다른 사람은 검사를 수행하는 방식이다.<br>코드에 대한 책임을 공유하고, 비형식적인 검토를 수행할 수 있다.<br>코드 개선을 위한 리팩토링을 장려하며, 생산성이 떨어지지 않는다. |
|                      | Planning Game                  | 게임처럼 선수와 규칙, 목표를 두고 기획에 임한다.                                                                                                                                                                 |
|                      | Test Driven Development        | 실제 코드를 작성하기 전에 단위 테스트부터 작성 및 수행하며, 이를 기반으로 코드를 작성한다.                                                                                                                       |
|                      | Whole Team                     | 개발 효율을 위해 고객을 프로젝트 팀원으로 상주시킨다.                                                                                                                                                            |
| Continuous Process   | Continuous Integration         | 상시 빌드 및 배포를 할 수 있는 상태로 유지한다.                                                                                                                                                                  |
|                      | Design Improvement             | 기능 변경 없이 중복성/복잡성 제거, 커뮤니케이션 향상, 단순화, 유연성 등을 위한 재구성을 수행한다.                                                                                                                |
|                      | Small Releases                 | 짧은 주기로 잦은 릴리즈를 함으로써 고객이 변경사항을 볼 수 있게 한다.                                                                                                                                            |
| Shared Understanding | Coding Standards               | 소스 코드 작성 포맷과 규칙들을 표준화된 관례에 따라 작성한다.                                                                                                                                                    |
|                      | Collective Code Ownership      | 시스템에 있는 소스 코드는 팀의 모든 프로그래머가 누구든지 언제라도 수정할 수 있다.                                                                                                                               |
|                      | Simple Design                  | 가능한 가장 간결한 디자인 상태를 유지한다.                                                                                                                                                                       |
|                      | System Metaphor                | 최종적으로 개발되어야 할 시스템의 구조를 기술한다.                                                                                                                                                               |
| Programmer Welfare   | Sustainable Pace               | 일주일에 40시간 이상 작업 금지. 2주 연속 오버타임을 금지한다.                                                                                                                                                    |

**효과적인 프로젝트 관리를 위한 3대 요소**

- 사람(People) - 인적 자원
- 문제(Problem) - 문제 인식
- 프로세스(Process) - 작업 계획

# 4. SCRUM

## **SCRUM**

**SCRUM 개념과 특징**

- 요구사항 변경에 신속하게 대처할 수 있는 반복적이고 점진적인 소규모 팀원 간 활발한 소통과 협동심이 필요한 팀 중심의 소프트웨어 개발 방법론이다.
- 신속하게 반복적으로 실제 작동하는 소프트웨어를 제공한다.
- 개발자들의 팀 구성과 각 구성원의 역할, 일정 결과물 및 그 외 규칙을 정하는 것을 말한다.
- 기능 개선점에 우선순위를 부여하고, 개발 주기 동안 실제 동작 가능한 결과를 제공한다.
- 개발 주기마다 적용된 기능이나 개선점의 리스트를 제공한다.
- 커뮤니케이션을 위하여 팀은 개방된 공간에서 개발하고, 매일 15분 정도 회의를 한다.
- 팀원 스스로 팀을 구성해야 한다.(Self Organizing)
- 개발 작업에 관한 모든 것을 팀원 스스로 해결해야 한다.(Cross Functional)

**SCRUM 기본 원리**

- 기능 협업을 기준으로 배치된 팀은 스프린트 단위로 소프트웨어를 개발한다.
- 스프린트는 고정된 30일의 반복이며, 스프린트를 시행하는 작업은 고정된다.
- 요구사항, 아키텍처, 설계가 프로젝트 전반에 걸쳐 잘 드러나야 한다.
- 정해진 시간을 철저히 지켜야 하며, 완료된 모든 작업은 제품 백로그에 기록된다.
- 가장 기본적인 정보 교환 수단은 일일 스탠드 업 미팅, 또는 일일 스크럼이다.

**SCRUM 팀의 역할**

| 담당자                     | 역할                                                                                                                                                                                                                                                                                                                                                               |
| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 제품 책임자(Product Owner) | - 개발 목표에 이해도가 높은 개발 의뢰자, 사용자가 담당한다. <br> - 제품 요구사항을 파악하여 기능 목록(Product Backlog)을 작성한다.<br>- 제품 테스트 수행 및 요구사항 우선순위를 갱신한다.<br>- 업무 관점에서 우선순위와 중요도를 표시하고 신규 항목을 추가한다.<br>- 스프린트 계획 수립까지만 임무를 수행한다.<br>- 스프린트가 시작되면 팀 운영에 관여하지 않는다. |
| 스크럼 마스터              | - 업무를 배분만 하고 일은 강요하지 않으며 팀을 스스로 조직하고 관리하도록 지원한다. 개발 과정 장애 요소를 찾아 제거한다.<br>- 개발 과정에서 스크럼의 원칙과 가치를 지키도록 지원한다.                                                                                                                                                                              |

## **SCRUM 과정**

**Product Backlog**

- 제품 개발에 필요한 모든 요구사항(User Story)을 우선순위에 따라 나열한 목록이다.
- 개발 과정에서 새롭게 도출되는 요구사항으로 인해 지속해서 업데이트된다.
- 제품 백로그에 작성된 사용자 스토리를 기반으로 전체 일정 계획인 릴리즈 계획을 수립한다.

**Sprint**

- 작은 단위의 개발 업무를 단기간에 전력 질주하여 개발한다는 의미로 반복 주기(2~4주)마다 이해 관계자에게 일의 진척도를 보고한다.

**Sprint Planning Meeting**

- Product Backlog(제품 기능 목록)에서 진행할 항목을 선택한다.
- 선택한 Sprint에 대한 단기 일정을 수립하고, 요구사항을 개발자들이 나눠 작업할 수 있도록 Task 단위로 나눈다.
- 개발자별로 Sprint Backlog를 작성하고 결과물에 대한 반복 완료 시 모습을 결정한다.
- 수행에 필요한 요구사항을 SCRUM Master에게 보고하여 이해관계자로부터 지원을 받는다.

**Daily SCRUM MEETING**

- 매일 약속된 시간에 짧은 시간 동안(약 15분) 서서 진행 상황만 점검한다.
- 한 사람씩 어제 한 일과 오늘 할 일을 이야기하고 스프린트 작업 목록을 잘 개발하고 있는지 확인한 뒤 완료된 세부 작업 항목을 완료 상태로 옮겨 스프린트 현황판에 갱신한다.
- 스크럼 마스터는 방해 요소를 찾아 해결하고 잔여 작업 시간을 소멸 차트(Burn down Chart)에 기록한다.

**Finished Work**

- 모든 스프린트 주기가 완료되면 제품 기능 목록(Product Backlog)의 개발 목표물이 완성된다.

**스프린트 리뷰(Sprint Review)**

- 스프린트 검토 회의(Sprint Review)에 개발자와 사용자가 같이 참석한다.
- 하나의 스프린트 반복 주기 (2~4주)가 끝나면 실행 가능한 제품이 생성되며 이에 대해 검토하며, 검토는 가능한 4시간 안에 마무리한다.
- 개선해야 할 사항에 대하여 제품 책임자(Product Owner)는 피드백을 정리하고 제품 백로그(Product Backlog)를 작성하여 다음 스프린트에 적용한다.

**스프린트 회고(Sprint Retrospective)**

- 스프린트에서 수행한 활동과 결과물을 살표본다.
- 개선점이 없는지 살펴보고 문제점을 기록하는 정도로 진행한다.
- 팀의 단점을 찾기보다는 강점을 찾아 팀 능력을 극대화한다.
- 개발 추정 속도와 실제 작업 속도를 비교하고 차이가 있다면 이유를 분석해본다.

# 5. 현행 시스템 분석

## **현행 시스템 분석**

**현행 시스템 분석의 정의와 목적**

- 현행 시스템이 어떤 하위 시스템으로 구성되어 있는지 파악하는 절차를 의미한다.
- 현행 시스템의 제공 기능과 타 시스템과의 정보 교환 분석을 파악한다.
- 현행 시스템의 기술 요소와 소프트웨어, 하드웨어를 파악한다.
- 목적 : 개발 시스템의 개발 범위를 확인하고 이행 방향성을 설정한다.

**현행 시스템 파악 절차**

- 1단계(시스템 구성 파악 - 시스템 기능 파악 - 시스템 인터페이스 현황 파악)
- 2단계(아키텍처 파악 - 소프트웨어 구성 파악)
- 3단계(시스템 하드웨어 현황 파악 - 네트워크 구성 파악)

**시스템 아키텍처**

- 시스템 내의 상위 시스템과 하위 시스템들이 어떠한 관계로 상호작용하는지 각각의 동작 원리와 구성을 표현한 것이다.
- 단위 업무 시스템별로 아키텍처가 다른 경우 핵심 기간 업무 처리 시스템을 기준으로 한다.
- 시스템의 전체 구조, 행위, 그리고 행위 원리를 나타내며 시스템이 어떻게 작동하는지 설명하는 틀이다.
- 시스템의 목적 달성을 위해 시스템에 구성된 각 컴포넌트를 식별하고 각 컴포넌트의 상호작용을 통하여 어떻게 정보가 교환되는지 설명한다.

시스템 아키텍처 ↔ 소프트웨어 아키텍처 => 소프트웨어 상세 설계

## **시스템 및 인터페이스 현황 파악**

**시스템 구성 파악**

- 조직 내의 주요 업무를 기간 업무와 지원 업무로 구분하여 기술한다.
- 모든 단위 업무를 파악할 수 있도록 하며, 시스템 내의 명칭, 기능 등 주요 기능을 명시한다.
- 시스템 구성 현황 작성 예

| 구분      | 시스템명    | 시스템 내용                                          |
| --------- | ----------- | ---------------------------------------------------- |
| 기간 업무 | 단위 A 업무 | 기간 단위 업무 A 처리를 위한 A1, A2 등의 기능을 제공 |
|           | 단위 B 업무 | 기간 단위 업무 B 처리를 위한 B1, B2 등의 기능을 제공 |
| 지원 업무 | 지원 C 업무 | 지원 업무 C 처리를 위한 C1, C2 등의 기능을 제공      |

**시스템 기능 파악**

- 단위 업무 시스템이 현재 제공하고 있는 기능을 주요 기능과 하부 기능으로 구분하여 계층형으로 표시한다.
- 시스템 기능 파악 예

| 시스템명          | 기능 L1 | 기능 L2      | 기능 L3       |
| ----------------- | ------- | ------------ | ------------- |
| A단위 업무 시스템 | 기능 1  | 하부 기능 11 | 세부 기능 111 |
|                   |         |              | 세부 기능 112 |
|                   |         | 하부 기능 12 | 세부 기능 121 |
|                   |         |              | 세부 기능 122 |
|                   | 기능 2  | 하부 기능 21 | 세부 기능 211 |
|                   |         |              | 세부 기능 212 |

**인터페이스 현황 파악**

- 현행 시스템의 단위 업무 시스템이 타 단위 업무 시스템과 서로 주고받는 데이터의 연계 유형, 데이터 형식과 종류, 프로토콜 및 주기 등을 명시한다.
- 데이터 형식 ex. XML, 고정 Format, 가변 Format
- 통신 규약 ex. TCP/IP, X.25
- 연계 유형 ex. EAI, FEP
- 인터페이스 현황 작성 예

| 송신 시스템       | 수신 시스템        | 연동 데이터 | 연동 형식 | 통신 규약 | 연계 유형 | 주기  |
| ----------------- | ------------------ | ----------- | --------- | --------- | --------- | ----- |
| A단위 업무 시스템 | 대외 기관 시스템 C | 연체 정보   | XML       | TCP/IP    | EAI       | 1시간 |
| A단위 업무 시스템 | 대외 기관 시스템 D | 신용 정보   | XML       | X.25      | FEP       | 수시  |

**EAI(Enterprise Application Integration, 기업 애플리케이션 통합)**

- 기업 내의 컴퓨터 애플리케이션들을 현대화하고, 통합하고, 조정하는 것을 목표로 세운 계획, 방법 및 도구 등을 의미한다.

**FEP(Front-End Processor, 전위 처리기)**

- 입력 데이터를 프로세서가 처리하기 전에 미리 처리하여 프로세서가 처리하는 시간을 줄여주는 프로그램이나 하드웨어이다.
- 여러 통신 라인을 중앙 컴퓨터에 연결하고 터미널의 메시지(Message)가 보낼 상태로 있는지 받을 상태로 있는지 검색한다. 통신 라인의 에러를 검출한다.

## **소프트웨어, 하드웨어, 네트워크 현황 파악**

**소프트웨어 구성 파악**

- 시스템 내의 단위 업무 시스템의 업무 처리용 소프트웨어의 품명, 용도, 라이센스 적용 방식, 라이센스 수를 명시한다.
- 시스템 구축 시 많은 예산 비중을 차지하므로 라이센스 적용 방식과 보유한 라이센스 수량 파악이 중요하다.
- 라이센스 적용 방식 단위 : 사이트, 서버, 프로세서, 코어, 사용자 수

**하드웨어 구성 파악**

- 각 단위 업무 시스템의 서버 위치 및 주요 사양, 수량, 이중화 여부를 파악한다.
- 서버 사양 : CPU 처리 속도, 메모리 크기, 하드 디스크의 용량
- 서버 이중화 : 장애 시 서비스의 지속 유지를 위해 운영
- 기간 업무의 장애 대응 정책에 따라 필요 여부가 달라진다.
- 현행 시스템에 이중화가 적용되어 있다면 대부분 목표 시스템도 이중화가 요구되므로 그에 따른 기술 난이도, 비용 증가 가능성을 파악한다.

**네트워크 구성 파악**

- 현행 업무 처리 시스템의 네트워크 구성 형태를 그림으로 표현한다.
- 장애 발생 시 추적 및 대응 등의 다양한 용도로 활용된다.
- 서버의 위치, 서버 간 연결 방식 등을 파악한다.
- 물리적인 위치 관계, 조직 내 보안 취약성 분석 및 대응 방안을 파악한다.

**개발 기술 환경 분석**

- 개발 대상 시스템의 플랫폼, OS, DBMS, MiddleWare 등을 분석한다.

## **플랫폼(Platform)**

**플랫폼**

- 응용 소프트웨어 + (하드웨어 + 시스템 소프트웨어)
- 다양한 애플리케이션이 작동하는 기본이 되는 운영체제 소프트웨어를 의미한다.
- 종류 : JAVA 플랫폼, .NET 플랫폼, IOS, Android, Windows
- 기능 : 개발/운영/유지보수 비용의 감소, 생산성 향상, 동일 플랫폼 간의 네트워크 효과

**플랫폼 성능 특성 분석**

- 현행 시스템의 사용자가 요구사항을 통하여 시스템 성능상의 문제를 요구할 경우 플랫폼 성능 분석을 통하여 사용자가 느끼는 속도를 파악하고 개선 방향을 제시할 수 있다.
- 특성 분석 항목 : 응답 시간(Response Time), 가용성(Availavilty), 사용률(Utilization)

**현행 시스템의 OS 분석 항목 및 고려사항**

- 분석 항목 : 현재 정보 시스템의 OS 종류와 버전, 패치 일자, 백업 주기 분석
- 고려사항 : 가용성, 성능, 기술 지원, 주변기기, 구축 비용(TCO)
- 현행 환경 분석 과정에서 라이센스의 종류, 사용자 수, 기술의 지속 가능성 등을 고려해야 한다.
- 메모리 누수 : 실행 SW가 정상 종료되지 않고 남아있는 증상
- TCO(Total Cost of Ownership) : 일정 기간 자산 획득에 필요한 직/간접적인 총비용으로 HW,SW 구매 비용, 운영 교육, 기술 지원, 유지보수, 손실 에너지 사용 비용 등이 있다.

**오픈 라이센스 종류**

- 소스 코드가 공개되어 누구나 특별한 제한 없이 소스를 사용할 수 있으며 대표적으로 Linux가 있다.
- GNU(GNU's Not Unix) : 컴퓨터 프로그램은 물론 모든 관련 정보를 돈으로 주고 구매하는 것을 반대하는 것이 기본 이념이다.
- GNU GPLv1(General Public License) : 소스 코드를 공개하지 않으면서 바이너리만 배포하는 것을 금지하며, 사용할 수 있는 쉬운 소스 코드를 같이 배포해야 한다.
- BSD(Berkeley Software Distributtion) : 아무나 제작할 수 ㅅ있고, 수정한 것을 제한 없이 배포할 수 있다. 단, 수정본의 재배포는 의무적인 사항이 아니다. 공개하지 않아도 되는 상용 소프트웨어에서도 사용할 수 있다.
- Apache 2.0 : Apache 재단 소유의 SW 적용을 위해 제공하는 라이센스이다. 소스 코드 수정 배포 시 Apache 2.0을 포함해야 한다. (ex. Android, HADOOP - HADOOP은 다수의 저렴한 컴퓨터를 하나처럼 묶어서 대량의 데이터를 처리하는 기술이다.)

**플랫폼 성능 특성 분석 방법**

- 기능 테스트(Performance Test) : 현재 시스템의 플랫폼을 평가할 수 있는 기능 테스트를 수행한다.
- 사용자 인터뷰 : 사용자를 대상으로 현행 플랫폼 기능의 불편함을 인터뷰한다.
- 문서 점검 : 플랫폼과 유사한 플랫폼의 기능 자료를 분석한다.

## **현행 시스템 DBMS 분석**

**DBMS(DataBase Management System)**

- 종속성과 중복성의 문제를 해결하기 위해서 제안된 시스템이다.
- 응용 프로그램과 데이터의 중재자로서 모든 응용 프로그램들이 데이터베이스를 공유할 수 있도록 관리한다.
- 데이터베이스의 구성, 접근 방법, 관리 유지에 대한 모든 책임을 진다.
- 종류 : Oracle, IBM DB2, Microsoft SQL Server, MySQL, SQ Lite, MongoDB, Redis

**현행 시스템 DBMS 분석**

- DBMS의 종류, 버전, 구성 방식, 저장 용량, 백업 주기, 벤더의 유지보수 여부 가능성을 분석한다.
- 테이블 수량, 데이터 증가 추이, 백업 방식 등을 분석한다.
- 논리/물리 테이블의 구조도를 파악하여 각 테이블의 정규화 정도, 조인 난이도, 각종 프로시저, 트리거 등을 분석한다.

**DBMS 분석 시 고려사항**

| 구분        | 설명                                                                                                                                                  |
| ----------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| 가용성      | 장시간 운영 시 장애 발생 가능성, 패치 설치를 위한 재 기동 시간과 이중화 및 복제 지원, 백업 및 복구 편의성 등을 고려한다.                              |
| 성능        | 대규모 데이터 처리 성능(분할 테이블의 지원 여부), 대량 거래 처리 성능 및 다양한 튜닝 옵션 지원, 비용 기반 최적화 지원 및 설정의 최소화 등을 고려한다. |
| 기술 지원   | 제조업체의 안정적인 기술 지원, 같은 DBMS 사용자들 간의 정보 공유 여부와 오픈소스 여부 등을 고려한다.                                                  |
| 상호 호환성 | 설치 가능한 운영체제 종류를 파악하여 다양한 운영체제에서 지원되는지 확인한다. JDBC, ODBC 등 상호 호환성이 좋은 제품을 선택한다.                       |
| 구축 비용   | 라이센스 정책 및 비용, 유지 또는 관리 비용, 총 소유 비용(TCO)을 고려한다.                                                                             |

# 6. 요구사항 개발

## **요구사항 개발**

**요구공학(Requirements Engineering)**

- 소프트웨어 개발 시 사용자 요구가 정확히 반영된 시스템 개발을 위하여 사용자의 요구를 추출, 분석, 명세, 검증, 관리하는 구조화된 활동 집합이다.
- 요구사항을 정의하고, 문서로 만들고 관리하는 프로세스를 의미한다.
- 효과적인 의사소통을 통하여 공통 이해를 설정하며, 불필요한 비용 절감, 요구사항 변경 추적이 가능해진다.
- 분석 결과의 문서화를 통해 향수 유지보수에 유용하게 활용할 수 있다.
- 자료 흐름도, 자료 사전 등이 효과적으로 이용될 수 있으며, 더 구체적인 명세를 위해 소단위 명세서(Mini-Spec)가 활용될 수 있다.

**요구공학의 목적**

- 소프트웨어 개발 시 이해관계자 사이의 원활한 의사소통 수단을 제공한다.
- 요구사항 누락 방지, 상호 이해 오류 등의 제거로 경제성을 제공한다.
- 요구사항 변경 이력 관리를 통하여 개발 비용 및 시간을 절약할 수 있다.
- 비용과 일정에 대한 제약설정과 타당성 조사, 요구사항 정의 문서화 등을 수행한다.

**요구공학(개발) 프로세스**

- 요구사항을 명확히 분석하여 검증하는 진행 순서를 의미한다.
- 개발 대상에 대한 요구사항을 체계적으로 도출한다.
- 도출된 요구사항을 분석하여 분석 결과를 명세서에 정리한다.
- 정리된 명세서를 마지막으로 확인, 검증하는 일련의 단계를 말한다.
- 경제성, 기술성, 적법성, 대안성 등 타당성 조사가 선행되어야 한다.

**SWEBOK에 따른 요구사항 개발 프로세스**

- 도출(Elicitation) => 분석(Analysis) => 명세(Specification) => 확인(Validation)

**요구사항 도출(Requirement Elicitation)**

- 소프트웨어가 해결해야 할 문제를 이해하는 첫 번째 단계이다.
- 현재의 상태를 파악하고 문제를 정의한 후 문제 해결과 목표를 명확히 도출하는 단계이다.
- 요구사항의 위치와 수집 방법과 관련되어 있다.
- 이해관계자(Stakeholder)가 식별되며, 개발팀과 고객 사이의 관계가 만들어지는 단계이며, 다양한 이해관계자와 효율적인 의사소통이 중요하다.
- 요구사항 도출 기법 : 고객의 발표, 문서 조사, 설문, 업무 절차 및 양식 조사, 브레인스토밍, 워크숍, 인터뷰, 관찰 및 모델의 프로토타이핑, Use Case, 벤치마킹, BPR(업무 재설계), RFP(제안요청서)

**요구사항 분석(Requirement Analysis)**

- 소프트웨어가 환경과 어떻게 상호작용하는지 이해하고, 사용자의 요구사항을 걸러 내기 위한 과정을 통하여 요구사항을 도출하고, 요구사항 정의를 문서화하는 과정이다. (사용자의 요구사항은 구조화와 열거가 어려워, 명확하지 못하거나 모호한 부분이 많다.)
- 도출된 사항을 분석하여 소프트웨어 개발 범위를 파악하고 개발 비용, 일정에 대한 제약을 설정하고 타당성 조사를 수행한다.
- 요구사항 간 상충하는 것을 해결하고, 소프트웨어의 범위(비용과 일정)를 파악하고 타당성 조사를 시행한다.
- 요구사항 기술 시 요구사항 확인, 요구사항 구현의 검증, 비용 추정 등의 작업이 가능하도록 충분하고 정확하게 기술한다.
- 요구분석을 위한 기법 : 사용자 의견 청취, 사용자 인터뷰, 현재 사용 중인 각종 문서 분석과 중재, 관찰 및 모델 작성 기술, 설문 조사를 통한 의견을 수렴한다.

**요구사항 분석 수행 단계**

- 문제 인식 : 인터뷰, 설문 조사 등 도구를 활용하여 요구사항을 파악하는 과정이다.
- 전개 : 파악한 문제를 자세히 조사하는 작업이다.
- 평가와 종합 : 요구들을 다이어그램이나 자동화 도구를 이용하여 종합하는 과정이다.
- 검토 : 요구분석 작업의 내용을 검토, 재정리하는 과정이다.
- 문서화 : 요구사항 분석 내용을 문서로 만드는 단계이다.

**요구사항 분류**

- 기술 내용에 따른 분류 : 기능 요구사항, 비기능 요구사항
- 기술 관점 및 대상에 따른 분류 : 시스템 요구사항, 사용자 요구사항.

**요구사항 분류 기준**

- 기능 요구사항, 비기능 요구사항을 구분하고 우선순위 여부를 확인한다.
- 요구사항이 하나 이상의 고수준 요구사항으로부터 유도된 것인지 확인한다.
- 이해관계자나 다른 원천(Source)으로부터 직접 발생한 것인지 확인한다.
- 요구사항이 제품에 관한 것인지 프로세스에 관한 것인지 확인하고 요구사항이 소프트웨어에 미치는 영향의 범위를 확인한다.
- 요구사항이 소프트웨어 생명주기 동안에 변경이 발생하는지 확인한다.

**기능적 요구사항 VS 비기능적 요구사항**

| 기능적 요구사항                                        | 비기능적 요구사항                                                                |
| ------------------------------------------------------ | -------------------------------------------------------------------------------- |
| 시스템이 실제로 어떻게 동작하는지에 관점을 둔 요구사항 | 시스템 구축에 대한 성능, 보안, 품질, 안정성 등으로 실제 수행에 보조적인 요구사항 |

**요구사항 명세(Requirement Specification)**

- 시스템 정의, 시스템 요구사항, 소프트웨어 요구사항을 작성한다.
- 체계적으로 검토, 평가, 승인될 수 있도록 문서로 만드는 것을 의미한다.
- 기능 요구사항은 빠지는 부분 없이 명확하게 기술한다.
- 설계 과정의 오류사항을 추적할 수 있어야 한다.
- 비기능 요구사항은 필요한 것만 명확하게 기술한다.
- 개발자가 효과적으로 설계할 수 있고 사용자가 쉽게 이해할 수 있도록 한다.

**요구사항 명세 기법**

| 구분 | 정형 명세                                                                      | 비정형 명세                                                                                                            |
| ---- | ------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------- |
| 기법 | 수학적 기반/모델링 기반                                                        | - 상태/기능/객체 중심 명세 기법<br>- 자연어 기반                                                                       |
| 종류 | - Z,VDM<br>- Petri-Net(모형 기반)<br>- LOTOS(대수적 방법)<br> - CSP, CCS       | - FSM(Finite State Machine)<br>- Decision Table, ER 모델링<br>- State Chart(SADT)<br>- UseCase<br>- 사용자 기반 모델링 |
| 장점 | - 시스템 요구 특성을 정확하고 간결하게 명세할 수 있다.<br>- 명세/구현의 일치성 | - 명세 작성 이해 용이<br>- 의사전달 방법 다양성                                                                        |
| 단점 | - 낮은 이해도<br>- 이해관계자의 부담 가중                                      | - 불충분한 명세 기능<br>- 모호성                                                                                       |

**요구사항 명세 속성**

- 정확성 : 요구사항은 정확해야 한다.
- 명확성 : 단 한 가지로만 해설되어야 한다.
- 완전성 : 모든 것이 표현(기능+비기능) 가능해야 한다.
- 일관성 : 요구사항 간 충돌이 없어야 한다.
- 수정 용이성 : 요구사항 변경이 가능해야 한다.
- 추적성 : RFP, 제안서를 통해 추적 가능해야 한다.

**요구사항 확인(Requirement Validation)**

- 요구사항 분석 단계를 거쳐 문서로 만들어진 내용을 확인하고 검증하는 단계이다.
- 일반적으로 요구사항 관리 도구를 이용하여 이해관계자들이 문서를 검토해야 하고, 요구사항 정의 문서들에 대해 형상 관리를 한다.
- 회사의 표준에 적합하고 이해할 수 있고, 일관성이 있고, 완전한지 검증한다.
- 요구분석가가 요구사항을 이해했는지 확인(Validation)이 필요하다.
- 리소스가 요구사항에 할당되기 전에 문제를 파악하기 위하여 다음과 같은 검증을 수행한다. (표준에 적합한가, 이해 가능한가, 일관성 있는가, 완전한가)
- 요구사항 관리 도구의 필요성 : 요구사항 변경으로 인한 비용 편익 분석, 요구사항 변경의 추적, 요구사항 변경에 따른 영향 평가

**형상관리(Configuration Management)**

- 애플리케이션 개발 단계에서 도출되는 프로그램, 문서, 데이터 등의 모든 자료를 형상 단위라고 하며, 이러한 자료의 변경을 관리함으로써 애플리케이션 버전 관리 등을 하는 활동이다.

**요구사항 할당(Requirement Allocation)**

- 요구사항을 만족시키기 위한 아키텍처 구성 요소를 식별하는 활동이다.
- 식별된 타 구성 요소와 상호작용 여부 분석을 통하여 추가 요구사항을 발견할 수 있다.

**정형 분석(Formal Analysis)**

- 구문(Syntax)과 형식적으로 정의된 의미(Semantics)를 지닌 언어로 요구사항을 표현한다.
- 정확하고 명확하게 표현하여 오해를 최소화할 수 있다.
- 요구사항 분석의 마지막 단계에서 이루어진다.

## **요구사항 확인 기법의**

**요구사항 확인 기법의 종류**

- 프로토타이핑(Prototyping), 모델 검증(Model Verification), 요구사항 검토(Requirement Reviews), 인수 테스트(Acceptance Tests)

**프로토타이핑(Prototyping)**

- 도출된 요구사항을 토대로 프로토타입(시제품)을 제작하여 대상 시스템과 비교하면서 개발 중에 도출되는 추가 요구사항을 지속해서 재작성하는 과정이다.
- 새로운 요구사항을 도출하기 위한 수단이다.
- 소프트웨어 엔지니어 관점에서 요구사항을 확인하기 위한 수단으로 많이 사용되고, 실제 구현 전에 잘못된 요구사항을 적용하는 자원 낭비를 방지할 수 있다.
- 절차 : 요구사항 분석 단계 => 프로토타입 설계 단계 => 프로토타입 개발 단계 => 고객의 평가 단계 => 프로토타입 정제 단계 => 완제품 생산 단계

| 장점                                                                                                                                                                                                                                                                                                                       | 단점                                                                                                                                                                                                                                     |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| - 분석가의 가정을 파악하고 잘못되었을 때 유용한 피드백을 제공한다.<br> - 문서나 그래픽 모델보다 프로토타입으로 이해하기 쉬워 사용자와 개발자 사이의 의사소통에 도움이 된다. <br> - 요구사항의 가변성이 프로토타이핑 이후에 급격히 감소한다.<br>- 빠르게 제작할 수 있으며, 반복 제작을 통하여 발전된 결과를 가져올 수 있다. | - 사용자의 관심이 핵심 기능에서 멀어질 수 있으며, 프로토타입의 디자인이나 품질 문제로 집중될 수 있다.<br> - 프로토타입 수행 비용이 발생한다.<br> - 전체 범위 중 일부 대상 범위만 프로토타입을 제작하면 사용성이 과대하게 평가될 수 있다. |

**모델 검증(Model Certification)**

- 분석 단계에서 개발된 모델의 품질을 검증ㅈ한다.
- 정적 분석(Static Analysis) : 객체 모델에서 객체들 사이에 존재하는 Communication Path(의사소통 경로)를 검증하기 위해 사용한다. 명세의 일관성과 정확성을 확인 분석하는 도구이다.
- 동적 문석(Dynamic Analysis) : 직접 실행을 통하여 모델을 검증하는 방식이다.

**인수 테스트(Acceptance Tests)**

- 최종 제품이 설계 시 제시한 요구사항을 만족하는지 확인하는 단계이다.
- 인수 시 각 요구사항의 확인 절차를 계획해야 한다.
- 종류 : 계약 인수 테스트, 규정 인수 테스트, 알파 검사, 베타 검사, 사용자 인수 테스트, 운영 인수 테스트

# 7. UML

## **개념 모델링(Conceptual Modeling)**

**개념 모델링**

- 요구사항을 이해하기 쉽도록 실 세계의 상황을 단순화하여 개념적으로 표현한 것을 모델이라고 하고, 이렇게 표현된 모델을 생성해 나가는 과정을 개념 모델링이라고 한다.
- 모델은 문제가 발생하는 상황에 대한 이해를 증진하고 해결책을 설명하므로 소프트웨어 요구사항 분석의 핵심이라 할 수 있다.
- 개발 대상 도메인의 엔티티(Entity)들과 그들의 관계 및 종속성을 반영한다.
- 요구사항별로 관점이 다르므로 개념 모델도 다양하게 표현되어야 한다.
- 대부분 UML(Unified Modeling Language)을 사용한다.
- 종류 : Use Case Diagram, Data Flow Model, State Model, Goal-Based Model, User Interactions, Object Model, Data Model

## **UML(Unified Modeling Language)**

**UML**

- 객체지향 소프트웨어 개발 과정에서 시스템 분석, 설계, 구현 등의 산출물을 명세화, 시각화, 문서화 할 때 사용하는 모델링 기술과 방법론을 통합하여 만든 범용 모델링 언어이다.
- Rumbaugh의 OMT 방법론과 Booch의 Booch 방법론, Jacobson의 OOSE 방법론을 통합하여 만든 모델링 개념의 공통 집합으로 객체지향 분석 및 설계 방법론의 표준 지정을 목표로 제안된 모델링 언어이다.
- OMG(Object Management Group)에서 표준화 공고 후 IMB, HP, Microsoft, Oracle 등이 참여하여 1997.1 버전 1.0을 Release 하였다.

**럼바우(Rumbaugh) 객체지향 분석 기법**

- 소프트웨어 구성 요소를 그래픽으로 모형화하였다.
- 객체 모델링 기법이라고도 한다.
- 객체 모델링 : 정보 모델링이라고도 한다. 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체를 다이어그램으로 표시한다.(OMT : Object Modeling Technique)
- 동적 모델링 : 제어 흐름, 상호작용, 동작 순서 등의 상태를 시간 흐름에 따라 상태 다이어그램으로 표시한다.
- 기능 모델링 : 여러 프로세스 간의 자료 흐름을 표시한다. 어떤 데이터를 입력하여 어떤 결과를 가져올 수 있을지를 표현한다.

**UML의 특성**

- 비주얼화 : 소프트웨어 구성 요소 간의 관계 및 상호작용을 시각화한 것이다.
- 문서화 : 소프트웨어 생명주기의 중요한 작업을 추적하고 문서화할 수 있다. 개발 프로세스 및 언어와 무관하게 개발자 간의 의사소통 도구를 제공한다.
- 명세화 : 분석, 설계, 구현의 완벽한 모델을 제공한다. 분석 단계-기능 모델, 설계 단계-동작 수준 모델, 구현 단계-상호작용 모델 수준으로 명세화할 수 있다. 단순 표기법이 아닌 구현에 필요한 개발적 요소 및 기능에 대한 명세를 제공한다.
- 구축 : 객체지향 언어와 호환되는 프로그래밍 언어는 아니지만, 모델이 객체지향 언어로 매핑될 수 있다.

**UML 소프트웨어에 대한 관점**

- 기능적 관점 : 사용자 측면에서 본 소프트웨어의 기능을 나타낸다. 사용 사례 모델링이라고도 한다. 요구분석 단계에서 사용한다. UML 에서는 Use Case Diagram을 사용한다.
- 정적 관점 : 소프트웨어 내부의 구성 요소 사이의 구조적 관계를 나타낸다. 객체, 속성, 연관 관계, 오퍼레이션의 시스템 구조를 나타내며, UML에서는 Class Diagram을 사용한다. (ex. 클래스 사이의 관계, 클래스 구성과 패키지 사이의 관계)
- 동적 관점 : 시스템의 내부 동작을 말하며, UML에서는 Sequence Diagram, State Diagram, Activity Diagram을 사용한다.

**UML의 기본 구성**

| 구성                | 설명                                                                                                                                                           |
| ------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 사물(Things)        | - 객체지향 모델을 구성하는 기본 요소이다. <br> - 객체 간의 관계 형성 대상이다.                                                                                 |
| 관계(Relationship)  | - 객체 간의 연관성을 표현하는 것이다.<br> - 종류 : 연관, 집합 포함, 일반화, 의존, 실체화                                                                       |
| 다이어그램(Diagram) | - 객체의 관계를 도식화한 것이다.<br>- 다양한 관점에서 의사소통할 수 있도록 View를 제공한다.<br> - 정적 모델 : 구조 다이어그램<br>- 동적 모델 : 행위 다이어그램 |

**스테레토 타입**

- UML에서 제공하는 기본 요소 외에 추가적인 확장 요소를 표현할 때 사용한다.
- UML 확장 모델에서 스테레오 타입 객체를 표현할 때 사용하는 기호는 쌍 꺾쇠와 비슷하게 생긴 길러멧(Guillemet) <<>>이며, 길러멧 안에 확장 요소를 적는다.

**UML 접근 제어자**

| 접근제어자 | 표기 | 설명                                                                                      |
| ---------- | ---- | ----------------------------------------------------------------------------------------- |
| Publice    | +    | 어떤 클래스의 객체에서든 접근 가능하다.                                                   |
| Private    | -    | 해당 클래스로 생성된 객체만 접근 가능하다.                                                |
| Protected  | #    | 해당 클래스와 동일 패키지에 있거나 상속 관계에 있는 하위 클래스의 객체들만 접근 가능하다. |
| Package    | ~    | 동일 패키지에 있는 클래스의 객체들만 접근 가능하다.                                       |

**연관 관계 다중성 표현**

| 표기          | 의미                        |
| ------------- | --------------------------- |
| 1             | 1 개체 연결                 |
| \* 또는 0..\* | 0이거나 그 이상 객체 연결   |
| 1..\*         | 1이거나 1 이상 객체 연결    |
| 0..1          | 0이거나 1 객체 연결         |
| 1,3,6         | 1이거나 3이거나 6 객체 연결 |
| n             | n개 객체 연결               |
| n..\*         | n이거나 n개 이상 객체 연결  |

## **UML 다이어그램의 분류**

**구조적 다이어그램(Structure Diagram)**

- 정적이고, 구조 표현을 위한 다이어그램이다.

| 다이어그램 유형                                     | 목적                                                                                                           |
| --------------------------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| 클래스 다이어그램(ClassDiagram)                     | 시스템 내 클래스의 정적 구조를 표현하고 시스템을 구성하는 클래스들 사이의 관계를 표현한다.                     |
| 객체 다이어그램(Object Diagram)                     | 객체 정보를 보여준다.                                                                                          |
| 복합체 구조 다이어그램(Composite Structure Diagram) | 복합 구조의 클래스와 컴포넌트 내부 구조를 표현한다.                                                            |
| 배치 다이어그램(Deployment Diagram)                 | 소프트웨어, 하드웨어, 네트워크를 포함한 실행 시스템의 물리 구조를 표현한다.                                    |
| 컴포넌트 다이어그램(Component Diagram)              | 컴포넌트 구조 사이의 관계를 표현한다.                                                                          |
| 패키지 다이어그램(Package Diagram)                  | 클래스나 유스케이스 등을 포함한 여러 모델 요소들을 그룹화해 패키지를 구성하고 패키지들 사이의 관계를 표현한다. |

**행위 다이어그램(Behavior Diagram)**

- 동적이고 순차적인 표현을 위한 다이어그램이다.
- 종류
  - Use Case Diagram
  - Activity Diagram
  - Collaboration Diagram
  - State Diagram
  - Interaction Diagram
    - Sequence Diagram
    - Communication Diagram
    - Interaction Overview Diagram
    - Timing Diagram

| 다이어그램 유형                             | 목적                                                                                                                                                                                                                                                                                                                                    |
| ------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 유스케이스 다이어그램(Use Case Diagram)     | 사용자 관점에서 시스템 행위를 표현한다.                                                                                                                                                                                                                                                                                                 |
| 활동 다이어그램(Activity Diagram)           | 업무 처리 과정이나 연산이 수행되는 과정을 표현한다.                                                                                                                                                                                                                                                                                     |
| 상태 머신 다이어그램(State Machine Diagram) | 객체의 생명주기를 표현한다. 동적 행위를 모델링하지만 특정 객체만을 다룬다. (ex. 실시간 임베디드 시스템, 게임, 프로토콜 설계에 이용)                                                                                                                                                                                                     |
| Collaboration Diagram                       | Sequence Diagram과 같으며, 모델링 공간에 제약이 없어 구조적인 면을 중시한다.                                                                                                                                                                                                                                                            |
| 상호작용 다이어그램(Interaction Diagram)    |                                                                                                                                                                                                                                                                                                                                         |
| 순차 다이어그램(Sequence Diagram)           | - 시스템의 동작을 정형화하고 객체의 메시지 교환을 쉽게 표현하고 시간에 따른 메시지 발생 순서를 강조한다.<br>- 요소 : 생명선(Life Line), 통로(Gate), 상호작용(Interaction Fragment), 발생(Occurrence), 실행(Execution), 상태 불변(State Invariant), 상호작용(Interaction Use), 메시지(Messages), 활성(Activations), 객체(Entitiy), Actor |
| 상호작용 개요 다이어그램                    | 여러 상호작용 다이어그램 사이의 제어 흐름을 표현한다.                                                                                                                                                                                                                                                                                   |
| 통신 다이어그램(Communication Diagram)      | 객체 사이의 관계를 중심으로 상호작용을 표현한다.                                                                                                                                                                                                                                                                                        |
| 타이밍 다이어그램(Timing Diagram)           | 객체 상태 변화와 시간 제약을 명시적으로 표현한다.                                                                                                                                                                                                                                                                                       |

## **클래스 다이어그램 관계 표현**

**Class Diagram**

- 시스템을 구성하는 객체 간의 관계를 추상화한 모델을 논리적 구조로 표현한다.
- 객체지향 개발에서 공통으로 사용된다.
- 분석, 설계, 구현 단게 전반에 지속해서 사용된다.(사용: Operation : 클래스의 동작을 의미하며, 클래스에 속하는 객체에 대하여 적용될 메소드를 정의한 것)

**UML 관계 표현**

| 구성             | 표시 | 설명                                                                                            |
| ---------------- | ---- | ----------------------------------------------------------------------------------------------- |
| 단방향 연관 관계 | ㅡ>  | 한쪽은 알지만 반대쪽은 상대방 존재를 모름                                                       |
| 양방향 연관 관계 | ㅡ   | 양쪽 클래스 객체들이 서로의 존재를 인식                                                         |
| 의존 관계        | ---> | 연관 관계와 같지만 메소드를 사용할 때와 같이 매우 짧은 시간만 유지                              |
| 일반화 관계      | ㅡ▷  | 객체지향에서 상속 관계(IS-A)를 표현하며, 한 클래스가 다른 클래스를 포함하는 상위 개념일 때 사용 |
| 집합/포함 관계   | ㅡ◇  | 클래스 사이 전체나 부분 이 같은 관계                                                            |
|                  | ㅡ◆  | 전체/부분 객체 라이프타임 의존적(전체 객체 삭제->부분 객체 삭제)                                |
| 실체화 관계      | ---▷ | 책임 집합 인터페이스와 실제로 실현한 클래스들의 사이                                            |

**UML 연관 관계(Association Relation)**

- 한 사물의 객체가 다른 사물의 객체와 연결된 것을 표현한다.
- 두 클래스가 서로 연관이 있다면 A, B 객체를 서로 참조할 수 있음을 표현한다.
- 이름 : 관계의 의미를 표현하기 위해 이름을 가질 수 있다.
- 역할 : 수행하는 역할을 명시적으로 이름을 가질 수 있다.

**UML 의존 관계(Dependency Relation)**

- 연관 관계와 같지만 메소드를 사용할 떄와 같이 매우 짧은 시간만 유지된다.
- 영향을 주는 객체(User)에서 영향을 받는 객체 방향으로 점선 화살표를 연결한다.

운전자ㅡ>자동차--->연료

운전자 & 자동차 = 연관 관계

자동차 & 연료 = 의존 관계

**UML 일반화 관계(Generalization Relation)**

- 객체지향에서 상속 관계(Is A Kind Of)를 표현한다.
- 한 클래스가 다른 클래스를 포함하는 상위 개념일 때 사용한다.(부모-자식)

**UML 집합 관계**

- A 객체가 B 객체에 포함된 관계이다.
- '부분'을 나타내는 객체를 다른 객체와 공유할 수 있다.
- '전체' 클래스 방향에 빈 마름모로 표시하고, or 관계에 놓이면 선 사이를 점선으로 잇고 {or}를 표시한다.

ex. 학생(부분) ㅡ◇ 학교(전체) ◇ㅡ 교사(부분)

**UML 포함 관계(Composition Relation)**

- 부분 객체가 전체 객체에 속하는 강한 집합 연관의 관계를 표현하는 클래스이다.
- '부분' 객체는 다른 객체와 공유 불가하고, '전체' 객체 방향에 채워진 마름모로 표시한다.

ex. 다리(부분) ㅡ◆ 책상(전체) ◆ㅡ 상판(부분)

**UML 실체화 관계(Realization Relation)**

- 인터페이스와 실제 구현된 일반 클래스 간의 관계로 존재하는 행동에 대한 구현을 표현한다.
- 한 객체가 다른 객체에게 오퍼레이션을 수행하도록 지정하는 의미적 관계이다.

ex. 미사일 ㅡ▷ 날다 ◁ㅡ 비행기

## **Use Case Diagram**

**Use Case Diagram의 개념**

- 객체지향 초반기 분석 작업에 작성되는 사용자의 요구를 기능적 측면에서 기술할 때 사용되는 도구로 Actor와 User Case로 구성된다.
- 얻어지는 결과는 개발 대상 시스템이 제공해야 하는 서비스 목록이 된다.

**Use Case Diagram 요소**

| 요소                                 | 설명                                                                                                                                                                                                                                                |
| ------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 시스템 경계(System Boundary)         | - 시스템이 제공해야 하는 사례(Use Case)들의 범위가 된다.<br>- 큰 규모의 객체로 구현되는 존재이다.                                                                                                                                                   |
| 액터(Actor)                          | - 서비스를 이용하는 외부객체이다.<br> - 시스템이 특정한 사례(Use Case)를 실행하도록 요구할 수 있는 존재이다.                                                                                                                                        |
| 유스케이스(Use Case)                 | - 시스템이 제공해야 하는 개별적인 서비스 기능이다.<br>- 서비스는 특정 클래스의 멤버 함수로 모델링된다.                                                                                                                                              |
| 접속 관계(communication Association) | - 액터/유스케이스 또는 유스케이스/유케이스 사이에 연결되는 관계이다.<br>- 액터나 유스케이스가 다른 유스케이스의 서비스를 이용하는 상황을 표현한다.                                                                                                  |
| 사용 관계(Uses Association)          | 여러 개의 유스케이스에서 공통으로 수행해야 하는 기능을 모델링하기 위해 사용한다.                                                                                                                                                                    |
| 확장 관계(Extends Association)       | - 확장 기능 유스케이스와 확장 대상 유스케이스 사이에 형성되는 관계로, 해당 유스케이스에 부가적인 유스케이스를 실행할 수 있을 때의 관계이다.<br>- 확장 대상 유스케이스를 수행할 때 특정 조건에 따라 확장 기능 유스케이스를 수행하는 경우에 적용한다. |

**Use Case Diagram 작성단계**

| 단계            | 식별                                                                                                                                                                                                                   |
| --------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 액터 식별       | - 모든 사용자 역할과 상호작용하는 타 시스템을 식별한다.<br>- 정보를 주고받는 하드웨어 및 지능형 장치를 식별한다.                                                                                                       |
| Use Case 식별   | - 액터가 요구하는 서비스와 정보를 식별한다.<br>- 액터가 시스템과 상호작용하는 행위를 식별한다.                                                                                                                         |
| 관계 정의       | - 액터와 액터 그리고 액터와 유스케이스의 관계 분석을 정의한다.<br>- 유스케이스와 유스케이스 간의 관계 분석을 정의한다.                                                                                                 |
| Use Case 구조화 | - 두 개의 상위 Use Case에 존재하는 공통 서비스를 추출한다.<br>- 추출된 서비스로 Use Case를 정의한다.<br>- 추출된 서비를 사용하는 Use Case와 관계를 정의한다.<br> - 조건에 따른 서비스 수행 부분을 분석하여 구조화한다. |

# 8. 소프트웨어 아키텍쳐

## **소프트웨어 아키텍처**

**소프트웨어 아키텍처**

- 개발 대상 시스템의 전반적인 구조를 체계적으로 설계하는 것이다.
- 다수의 이해관계자가 참여하는 복잡한 개발에서 상호이해, 타협, 의사소통을 체계적으로 접근하기 위한 것이다.
- 소프트웨어를 구성하는 컴포넌트들의 상호작용 및 관계, 각각의 특성을 기반으로 컴포넌트들이 상호 유기적으로 결합하는 소프트웨어의 여러 가지 원칙들의 집합이다.

**소프트웨어 아키텍처 품질 요구사항**

- 소프트웨어의 기능, 성능, 만족도 등의 요구사항이 얼마나 충족하는가를 나타내는 소프트웨어 특성의 핵심 집합이다.
- 사용자의 요구사항을 얼마나 충족시키느냐에 따라 확립된다.

**ISO/IEC 9126 모델**

- 소프트웨어 품질 특성과 평가를 위한 국제 표준이다.
- 내외부 품질 : 기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성으로 구분된다.
- 사용 품질 : 효과성, 생산성, 안정성, 만족도
- 외부지표(External Metrics) : 실행 가능한 SW, 시스템을 시험, 운영 또는 관찰을 통하여 시스템을 구성하고 있는 일부분으로부터 추출된 소프트웨어 제품의 측정에 사용한다. 사용자, 평가자, 시험자 및 개발자에게 시험 수행이나 운영 중에 소프트웨어 제품에 대한 품질을 평가하는 항목이다.
- 내부 지표(Internal Metrics) : 설계, 코딩 도중에 실행할 수 없는 SW 제품(명세서, 원시 코드 등)에 대하여 적용하고 설계상 요구되는 외부 품질을 성취하기 위하여 ISO 9126-3에 규정한다. 사용자, 평가자, 시험자 및 개발자가 소프트웨어 제품의 품질을 평가할 수 있도록 도움을 준다.

### ISO/IEC 품질 특성

1. 내/외부 품질
   - 기능성
     - 적합성
     - 정확성
     - 상호운용성
     - 보안성
     - 준수성
   - 신뢰성
     - 성숙성
     - 결함 허용성
     - 회복(복구)성
   - 사용성
     - 이해성
     - 학습성
     - 운용성
     - 친밀성
     - 준수성
   - 효율성
     - 시간 효율성
     - 자원 활용성
     - 준수성
   - 유지보수성
     - 분석성
     - 변경성
     - 안정성
     - 시험성
     - 준수성
   - 이식성
     - 적응성
     - 설치성
     - 공존성
     - 대체성
     - 준수성
2. 사용 품질
   - 효과성
   - 생산성
   - 안정성
   - 만족도

**ISO/IEC 25010**

- ISO/IEC 9126에서 ISO/IEC 25010으로 개정되어 특성 기준이 6개에서 8개로 증가하였다.
- 기존 : 기능성, 신뢰성, 사용성, 유지보수성, 이식성, 효율성
- 변경 : 기능 적합성, 실행 효율성, 호환성, 사용성, 신뢰성, 보안성, 유지보수성, 이식성, 부특성 일부가 증가

## **UI 표준을 위한 환경 분석**

**사용자 경향 분석**

- 기존/현존 UI 경향을 숙지하고 현재 UI 단점을 작성한다.
- 사용자의 요구사항을 파악하고, 쉽게 이해 가능한 기능 위주로 기술 영역을 정의한다.

**기능 및 설계 분석**

- 기능 조작성 분석 : 사용자 편의를 위한 조작에 관한 분석을 확인한다. (ex. 스크롤바 지원 가능 여부, 마우스 조작 시 동선 확인)
- 오류방지 분석 : 조작 시 오류에 대해 예상 가능한지 확인한다. (ex. 의도치 않는 페이지 이동, 기능 버튼의 명확한 구분 가능한지 확인, 기능 버튼 이름이 사용자 조작과 일치하는지 확인)
- 최소한의 조작으로 업무 처리 가능한 형태 분석 : 작업 흐름에 가장 적합한 레이아웃인지 확인한다. (ex. 기능 특성에 맞는 UI 확인 및 조작 단계 최소화와 동선 단순 여부 확인)
- UI의 정보 전달력 확인 : 중요정보 인지, 쉽게 전달 가능한지, 정보 제공의 간결성, 명확성을 확인하고 정보 제공 방식의 일관성, 사용자 이해성 확인, 상호연관성 높은 정보인지 확인한다. (ex. 오류 발생 시 해결 방법 접근 용이성 확인)

**요구사항 요소**

| 구분              | 설명                                                                                                                                                                                                   |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 데이터 요구       | - 사용자 요구 모델과 객체들의 핵심 특성에 기반하여 데이터 객체를 정리한다.<br> - 인터페이스에 영향을 줄 수 있으니 초기에 확인한다.<br> (ex. Email 메시지 속성 : 제목, 송신자, 송신일, 참조인, 답변 등) |
| 기능 요구         | - 동사형으로 사용자의 목적 달성을 위해 실행해야 할 기능을 설명한다.<br>- 기능 요구 목록으로 정리한다.<br>- 최대한 철저하게 작성해야 한다.                                                              |
| 제품, 서비스 품질 | - 감성 품질과 데이터/기능 요구 외 제품 품질, 서비스 품질을 고려한다.<br>- 시스템 처리 능력 등 정량화 가능한 요구사항을 확인한다.                                                                       |
| 제약 사항         | 비용, 데드라인, 시스템 준수에 필요한 규제 등 사전에 제약 사항의 변경 여부를 확인한다.                                                                                                                  |

**정황 시나리오 작성**

- 개발하는 서비스의 초기 모양을 상상하는 단계이다.
- 사용자 관점에서 작성하며 요구사항 정의에서 가장 기초적인 시나리오를 의미한다.
- 높은 수준과 낙관적인 상황에서 이상적 시스템 동작에 초점을 둔다.
- 육하원칙을 따르고 사용자가 주로 사용하는 기능 기반에서 작성한다.
- 간단명료하게 작성하여 정확하게 전달하고, 같은 동작 기능은 하나의 시나리오에 통합한다.
- 외부 전문가, 경험자에게 검토를 의뢰하도록 한다.
- 정황 시나리오 작성 예

| 정황 시나리오                                                                                              | 요구사항                                                                                                                                       |
| ---------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| - 사원은 출근하여 시스템에 로그인하고 오늘 업무를 확인한다.<br>- 어제 요청한 결제가 승인되었는지 확인한다. | - 로그인하면 맨 위 화면에 오늘 업무가 표시되어야 한다.<br>- 결제 요청 내역에 결제 승인 여부가 확인될 수 있도록 승인 내역은 다른 색을 이용한다. |

# 9. UI 표준 및 지침

## **UI 표준 및 지침**

**UI(User Interface)**

- 인간, 디지털 기기, 소프트웨어 사이에서 의사소통할 수 있도록 만들어진 매개체이다.
- 인간과 컴퓨터의 상호작용(HCI)에 필요한 화상, 문자, 소리, 수단(장치)을 의미한다.

**UI 분야**

- 표현에 관한 분야 : 전체적인 구성과 콘텐츠의 상세 표현을 위한 분야이다.
- 정보 제공과 전달 분야 : 물리적 제어를 통한 정보 제공과 전달을 위한 분야이다.
- 기능 분야 : 기능적으로 사용자가 쉽고 간편하게 사용하도록 하는 분야이다.

**UI의 특징**

- 실사용자의 만족도에 직접 영향을 준다.
- 적절한 UI 구성으로 편리성, 가독성, 동선의 축약 등으로 작업 시간을 줄일 수 있고 업무 효율을 높일 수 있다.
- 실사용자가 수행해야 할 기능을 구체적으로 제시한다.
- UI 설계 전 소프트웨어 아키텍처를 우선 숙지하고 있어야 한다.

**UI 개발 시스템이 가져야 할 기능**

- 사용자 입력의 검증
- 에러 처리의 에러 메시지 처리
- 도움과 프롬프트(Prompt) 제공
- 프롬프트 : 사용자의 명령을 받아들일 준비가 되었음을 모니터에 나타내는 표시(커서)

## **UI 설계**

**UI 설계 원칙**

- 직관성 : 누구나 쉽게 이해하고 사용할 수 있도록 한다.
- 유효성 : 사용자의 목적을 정확히 달성할 수 있도록 유용하고 효과적이어야 한다.
- 학습성 : 사용자가 쉽게 배우고 익힐 수 있어야 한다.
- 유연성 : 사용자의 요구를 최대한 수용하면서 오류를 최소화해야 한다.

**UI 설계의 필요성**

- 구현 대상 결과의 오류 최소화와 적은 노력으로 구현하는 결과를 얻을 수 있다.
- 막연한 작업 기능에 대하여 구체적 방법을 제시한다.
- 사용자 편의성을 높여 작업 시간 단축, 업무 이해도를 높인다.
- 정보 제공자/공급자 사이의 원활하고 쉬운 매개 임무를 수행한다.

**UI 설계 지침**

| 구분           | 설명                                                                          |
| -------------- | ----------------------------------------------------------------------------- |
| 사용자 중심    | 실사용자의 이해를 바탕으로 쉽게 이해하고 쉽게 사용할 수 있는 환경을 제공한다. |
| 일관성         | 사용자가 기억하기 쉽고 빠른 습득을 가능하도록 버튼이나 조작법을 제공한다.     |
| 단순성         | 인지적 부담을 줄이도록 조작 방법을 가장 간단히 작동하도록 한다.               |
| 가시성         | 주요 기능은 메인 화면에 배치하여 조작이 쉽게 한다.                            |
| 표준화         | 기능 구조의 선행 학습 이후 쉽게 이용할 수 있도록 디자인을 표준화한다.         |
| 접근성         | 사용자의 직무, 성별, 나이 등 다양한 계층을 수용해야 한다.                     |
| 결과 예측 가능 | 작동 대상 기능만 보고도 결과 예측이 가능해야 한다.                            |
| 명확성         | 사용자 관점에서 개념적으로 쉽게 인지할 수 있어야 한다.                        |
| 오류 발생 해결 | 오류가 발생하면 사용자가 상황을 정확히 인지할 수 있어야 한다.                 |

## **UI 표준**

**UI 구현 표준**

- 전체 시스템 개발 중에 개발자 간 협업을 통하여 각기 개발한 화면 간에 갖추어야 할 최소한의 UI 요소 및 배치 규칙 등의 규칙을 의미한다.
- UI에 공통으로 적용되어야 할 화면 구성, 화면 이동 등이 있다.

**UI 구현 지침**

- 소프트웨어 개발 시 효율적인 정보 전달이 가능하도록 UI 설계에서 지켜야 할 세부 사항을 규정하는 것이다.
- UI 요구사항, 구현 제약 사항 등 UI 개발 과정에서 꼭 지켜야 할 공통 조건을 의미한다.

**한국형 웹 콘텐츠 접근성 지침 2.1 4가지 원칙**

- 인식의 용이성 : 대체 텍스트, 멀티미디어 대체 수단, 명료성
- 운용의 용이성 : 입력 장치 접근성, 충분한 시간 제공, 광(光) 과민성 발작 예방, 쉬운 내비게이션
- 이해의 용이성 : 가독성, 예측 가능성, 콘텐츠의 논리성, 입력 도움
- 견고성 : 문법 준수, 웹 애플리케이션 접근성

## **UX(User eXperience)**

**UX 사용자 경험**

- 사용자가 제품을 대상으로 직/간접적으로 사용하면서 느끼고 생각하게 되는 지각과 반응, 행동 등 모든 경험을 의미한다.
- UI는 사람과 시스템 간의 상호작용을 의미하지만, UX는 제품과 서비스, 회사와 상호작용을 통해서 전체적인 느낌이나 경험을 말한다.
- UX에 영향을 주는 요소 : 성능, 시간

**모바일 사용자 UX 설계 시 고려사항(행정안전부 고시)**

- 시스템을 사용하는 대상, 환경, 목적, 빈도 등을 고려한다.
- 사용자가 직관적으로 서비스 이용 방법을 파악할 수 있도록 한다.
- 입력의 최소화, 자동 완성 기능을 제공한다.
- 사용자의 입력 실수를 수정할 수 있도록 되돌림 기능을 제공한다.
- 모바일 서비스의 특성에 적합한 디자인을 제공한다.

# 10. UI 설계

## **UI설계 단계**

**UI설계 단계**

- 문제 정의 : 시스템의 목적과 해결해야 할 문제를 정의한다.
- 사용자 모델 정의 : 사용자 특성을 결정하고, 소프트웨어 작업 지식 정도에 따라 초보자, 중급자, 숙련자로 구분한다.
- 작업 분석 : 사용자의 특징을 세분화하고 수행되어야 할 작업을 정의한다.
- 컴퓨터 오브젝트 및 기능 정의 : 작업 분석을 통하여 어떤 사용자 인터페이스에 표현할지를 정의한다.
- 사용자 인터페이스 정의 : 모니터, 마우스, 키보드, 터치스크린 등 물리적 입/출력 장치 등 상호작용 오브젝트를 통하여 시스템 상태를 명확히 한다.
- 디자인 평가 : 사용자 능력, 지식에 적합한가? 사용자가 사용하기 편리한가? 등의 평가를 의미하며, 사용성 공학을 통하여 사용성 평가를 할 수 있다. 평가 방법론으로는 GOMS, Heuristics 등이 있다.
- GOMS : 인간이 어떤 행위를 할지 예측하여 그 문제를 해결하는데 필요한 소요시간, 학습시간 등을 평가하기 위한 기법
- Heuristics : 논리적 근거가 아닌 어림짐작을 통하여 답을 도출해 내는 방법

**UI 상세 설계 단계**

| 설계                   | 실행사항                                                                                                                                                                                                                                           |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| UI 메뉴 구조 설계      | - 요구사항과 UI 표준 및 지침에 따라 사용자의 편의성을 고려한다.<br>- 요구사항 최종 확인, UI 설계서 표지 및 개정 이력을 작성한다.<br> - UI 구조 설계, 사용자 기반 메뉴 구조 설계 및 화면을 설계한다.                                                |
| 내/외부 화면과 폼 설계 | - UI 요구사항과 UI 표준 지침에 따라 하위 시스템 단위를 설계한다. 실행 차를 최소화하기 위하여 UI 설계 원리 검토 => 행위 순서 검토 => 행위 순서대로 실행 검토한다.<br> - 평가 차를 줄이기 위한 UI 설계 원리를 검토한다.                              |
| UI 검토 수행           | - UI 검토 보완을 위한 시뮬레이션 시연 구성원에는 컴퓨터 역할을 하기 위해 서류를 조작하는 사람, 전체적인 평가를 위한 평가 진행자, 관찰자가 있다. 이 평가 결과를 토대로 설계를 보완한다.<br> - UI 시연을 통한 사용성에 대한 검토 및 검증을 수행한다. |

**UI 상세 설계-시나리오 작성 원칙**

- UI 전체적 기능, 작동 방식을 개발자가 쉽게 이해할 수 있도록 구체적으로 작성한다.
- 대표 화면 레이아웃 및 하위 기능을 정의하고 Tree 구조나 Flowchart 표기법을 이용한다.
- 공통 적용이 가능한 UI 요소와 상호작용(Interaction)을 일반적인 규칙으로 정의한다.
- 상호작용의 흐름 및 순서, 분기, 조건, 루프를 명시한다.
- 예외 상황에 관한 사례를 정의하고 UI 시나리오 규칙을 지정한다.
- 기능별 상세 기능 시나리오를 정의하되 UI 일반 규칙을 지킨다.
- 시나리오 문서의 작성 요건 : 완전성, 일관성, 이해성, 가독성, 수정 용이성, 추적 용이성

**UI 흐름 설계서 구성**

- UI 설계서 표지 : 프로젝트 이름, 시스템 이름을 포함하여 작성한다.
- UI 설계서 개정 이력 : 처음 작성 시 '초안 작성'을 포함한다. 초기 버전은 1.0으로 설정하고 완성 시 버전은 x.0으로 바꾸어 설정한다.

**UI 요구사항 정의**

- 시스템 구조 : UI 프로토타입 재확인 후 UI 시스템 구조를 설계한다.
- 사이트맵 : UI 시스템 구조를 사이트맵 구조로 설계한다.
- 프로세스 정의 : 사용자 관점에서의 요구 프로세스 순서를 정리한다.
- 화면 설계 : UI 프로세스/프로토타입을 고려하여 페이지 별로 화면을 구성 및 설계한다.

## **UI 설계 도구**

**UI 설계에 도움을 주는 도구들**

- 와이어 프레임(Wire Frame) : UI 중심의 화면 레이아웃을 선(Wire)을 이용하여 대략적으로 작성한다.
- 목업(Mockup) : 실물과 흡사한 정적인 모형을 의미한다.
- 프로토타입(Prototype) : Interaction(상호작용)이 결합하여 실제 작동하는 모형이다.
- 스토리보드(Storyboard) : 정책, 프로세스, 와이어 프레임, 설명이 모두 포함된 설계 문서이다.

**와이어 프레임**

- 기획 단계 초기에 작성하며, 구성할 화면의 대략적인 레이아웃이나 UI 요소 등의 틀을 설계하는 단계이다.
- 개발 관계자(디자이너, 개발자, 기획자) 사이의 레이아웃 협의, 현재 진행 상황 등을 공유할 때 사용한다.
- 툴 : 핸드라이팅, 파워포인트, 키노트, Sketch, Balsamiq, Mockup, Adobe Experience Design, 카카오 오븐

**목업(Mockup)**

- 와이어 프레임보더 좀 더 실제 제품과 유사하게 만들어지는 실물 크기의 정적 모형으로 시각적으로만 구현된다.
- 툴 : 카카오 오븐, Balsamiq Mockup, Power Mockup

**스토리보드**

- UI/UX 구현에 수반되는 사용자와 작업, 인터페이스 간 상호작용을 시각화한 것이다.
- 개발자/디자이너와의 의사소통을 돕는 도구이다.
- 완성해야 할 서비스와 예상되는 사용자 경험을 미리 보기 위한 방법론이다.
- 작성 목적 : 설계에 필요한 조각을 모아 순서대로 놓고 배치해 보고 쌓아서 조립하는 과정으로 설계 단계에서 발생할 수 있는 문제를 미리 발견하고 대처하기 위한 과정이다.
- 작성 방법 : 상단/우측 => 제목, 작성자 기재, 좌측 => UI화면, 우측 => Description
- 작성 단계 : 메뉴 구성도 만들기 => 스타일 확정하기 => 설계하기

## **UI 프로토타입**

**UI Prototype**

- 도출된 요구사항을 토대로 프로토타입을 제작하여 대상 시스템과 비교하면서 개발 중에 도출되는 추가 요구사항을 지속해서 재작성하는 과정이다.
- 와이어 프레임, 스토리보드에 Interaction을 적용한 것이다.
- 동적인 형태로 구현된 모형이다.
- 툴 : HTML/CSS, Axure, Invision Studio, 카카오 오븐, Flinto, 네이버 Proto Now
- 작성 방법에 따른 분류 : 디지털 프로토타입, 페이퍼 프로토타입

**프로토타입의 장단점**

| 장점                                                                                       | 단점                                                                                                                                           |
| ------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| - 사용자 설득과 이해가 쉽다.<br>- 개발 시간이 감소한다.<br>- 오류를 사전에 발견할 수 있다. | - 수정이 많아지면 작업 시간이 늘어날 수 있다.<br>- 필요 이상으로 자원을 많이 소모한다.<br>- 정확한 문서 작업이 생략되는 문제가 발생할 수 있다. |

**프로토타입 작성 도구 및 방법**

|  구분   | 방법                                                                                                                                             |     비고     |
| :-----: | ------------------------------------------------------------------------------------------------------------------------------------------------ | :----------: |
| Analog  | - 포스트잇, 칠판, 종이, 펜 등을 이용한다.<br>- 소규모 개발, 제작 비용과 기간이 적을 경우 이용한다.<br>- 빠른 업무 협의가 필요한 경우 이용한다.   |    손,펜     |
|         | - 비용이 저렴하면서 즉시 변경이 가능하다.<br>- 회의 중 바로 작성할 수 있다.<br>- 상호 연관 관계가 복잡한 경우 표현이 어렵다.<br>- 공유가 어렵다. |      -       |
| Digital | Power Point, Acrobat, Invision, Marvel, Adobe Xd, Flinto, Priciple, Keynote, UX pin, HTML 등을 이용한다.                                         | Digital Tool |
|         | - 재사용성이 높지만 툴을 다룰 줄 아는 전문가가 필요하다.<br>- 목표 제품과 비슷하게 테스트할 수 있으며 수정이 수월하다.                           |      -       |

**UI Prototype 작성 시 고려사항**

- 프로토타입 계획작성, 프로토타입 범위 확인, 프로토타입 목표 확인, 프로토타입 기간 및 비용 확인, 프로토타입 산출물 확인, 프로토타입 유의사항 확인

**UI Prototype 계획 시 고려사항**

- 프로토타입 목표 확인, 프로토타입 환경 확인, 프로토타입 일정 확인, 프로토타입 범위 확인, 프로토타입 인원 확인, 프로토타입 아키텍쳐 검증 확인, 프로토타입 이슈 및 해결, 프로토타입 가이드 확정, 프로토타입 개발 생산성 확인, 프로토타입 결과 시연

**UI 프로토타입 제작 단계**

- 사용자 요구분석 => 프로토타입 작성 => 프로토타입 사용자 테스트 => 수정과 합의 단계

## **감성 공학**

**감성 공학**

- 인간의 소망으로 이미지나 감성을 구체적 제품 설계를 통하여 실현해 내는 공학적 접근 방법으로 인간과 컴퓨터 간의 상호작용 즉 HCI(Human Computer Interaction or Interface) 설계에 인간의 특성, 감성 등의 정량적 측정과 평가를 통하여 제품 환경 설계에 반영하는 기술이다.
- 인간이 가지고 있는 소망으로서의 이미지나 감성을 구체적인 제품 설계로 실현해 내는 인문 사회 과학, 공학, 의학 등 여러 분야의 학문이 융합된 기술이다.
- 감각 및 생체계측, 센서, 인공지능 등의 생체 제어 기술 등을 통해 과학적으로 접근한다.
- 최종 목표는 감성 공학을 통하여 인간이 쉽고 편리하고 쾌적하게 시스템과 어우러지는 것이다.
- 1988년 시드니 국제 학회에서 '감성 공학'으로 명명된다.

**감성 공학 접근 방법**

- 1류(의미 미분법) : 인간의 감각, 감성을 표현하는 어휘(형용사)를 이용하여 제품에 대한 이미지는 조사/분석하고, 디자인 요소에 연계하는 접근 방법이다.
- 2류 : 1류와 기본 틀은 공유하고, 감성 어휘 수집의 전 단계에서 평가자들의 생활 양식을 추가하였다. 제품에 대한 기호 및 수용를 분석 대상의 소속 지역, 생활 양식, 의식 문화를 분석하는 접근 방법이며, 1류와 함께 감성의 심리적 특성을 강조한다.
- 3류 : 1류의 감성 어휘 대신 평가자의 특정 시제품을 사용하여 자신의 감각 척도로 감성을 표출하는 방법이다. 평가자의 생리적 감각 계측을 통해서 그 객관성이 보완되고 정량화된 값으로 산출된다. 대상 제품의 물리적인 특성에 대하여 객관적인 지표와의 연관 분석을 통하여 제품 설계에 응용된다. 인간 감각 계측과 이의 활용이 강조된 접근 방법으로 감성의 생리적 특성을 중요시한다.

**HCI(Human computer Interaction or Interface)**

- 인간과 컴퓨터의 상호작용을 연구하여 어떻게 하면 좋은 제품을 만들 수 있는지를 연구한다.

**HCI 목적**

- 컴퓨터를 인간이 쉽게 사용할 수 있게 하여 상호작용(UX)을 개선하는 것이다.
- 컴퓨터의 도구로서 잠재력을 극대화해 인간의 의지를 더 자유롭게 한다.
- 인간의 창의력, 인간 사이의 의사소통과 협력을 증진하는데 있다.

**감성 공학 요소**

- 기초 기술, 구현 기술, 응용 기술

**감성 공학 관련 기술**

- 생체측정 기술, 인간 감성 특성 파악 기술, 감성 디자인 기술과 오감 센서 및 감성 처리 기술, 마이크로 기구 설계, 사용성 평가 기술 및 가상현실 기술

2 -
