# 1. 소프트웨어 공학의 개념

## **소프트웨어**

**소프트웨어(SW)의 개념**

- 컴퓨터를 동작시키고 어떤 일의 처리 순서와 방법을 지시하는 명령어의 집합인 프로그램과 프로그램의 수행에 필요한 절차, 규칙, 관련 문서 등을 총칭한다.
- 프로그램(Program) : 컴퓨터를 통해 일련의 작업을 처리하기 위한 명령어와 관련된 데이터의 집합을 의미한다.
- 자료 구조(Data Structure): 컴퓨터 기억 장치 내에 자료의 표현, 처리, 저장 방법 등을 총칭하는 것으로 데이터 간의 논리적 관계나 처리 알고리즘을 의미한다.
- 문서(Paper) : 소프트웨어를 개발함에 있어서 사용자 설명서, 소프트웨어 요구분석서, 평가서, 명세서, 프로젝트 계획서, 검사 계획서 등을 의미한다.

**소프트웨어의 특징**

- 상품성 : 소프트웨어를 개발하면 상품이 되어 판매가 된다.
- 복잡성 : 개발하는 과정이 복잡하고 관리가 어렵다.
- 변경 가능성 : 프로그램을 일부 수정하여 업그레이드 및 오류 수정 등을 할 수 있다.
- 복제성 : 복제가 용이해 쉽게 복사, 유통이 가능하다.

**시스템(System)의 개요와 기본 요소**

- 시스템의 개요
  - 컴퓨터로 처리 가능한 자료를 입력하고 저장, 처리, 가공해 출력할 수 있도록 설계/구현된 정보 체계를 의미한다.
  - 하나의 목적을 위해 다양한 요소가 유기적으로 결합된 것을 의미한다.
- 기본 요소
  - 입력, 처리, 출력, 제어, 피드백으로 구성된다.

**소프트웨어 위기(Software Crisis)**

- 컴퓨터의 발달 과정에서 소프트웨어의 개발 속도가 하드웨어의 개발 속도를 따라가지 못해 사용자들의 요구사항을 감당할 수 없는 문제가 발생함을 의미한다.
- 소프트웨어 위기의 원인
  - 하드웨어 비용을 초과하는 개발 비용의 증가
  - 개발 기간의 지연
  - 개발 인력 부족 및 인건비 상승
  - 성능 및 신뢰성 부족
  - 유지보수의 어려움에 따른 엄청난 비용

## **소프트웨어 공학(Software Engineering)**

**소프트웨어 공학의 이해**

- 경제적으로 신뢰도 높은 소프트웨어를 만들기 위한 방법, 도구와 절차들의 체계를 말한다.
- IEEEE(전기/전자기술협회)는 소프트웨어의 개발, 운용, 유지보수 및 파기에 대한 체계적인 접근 방법이라 정의하였다.

**소프트웨어 공학의 기본 원칙**

- 현대적인 프로그래밍 기술을 적용해야 한다.
- 신뢰성이 높아야 한다.
- 사용의 편리성과 유지보수성이 높아야 한다.
- 지속적인 검증 시행을 해야 한다.

**소프트웨어 공학 계층 구조**

- 도구 : 프로세스와 방법을 처리하는 기능을 제공하는 것이다.
- 방법론 : 소프트웨어를 설계하는데 기술적인 방법을 제공하는 것이다.
- 프로세스 : 소프트웨어의 가장 기초가 되며 개발에 사용되는 방법론과 도구가 적용되는 순서를 의미한다.

**소프트웨어 품질**

- 사용자의 요구대로 만들어져야 한다.
- 유지보수가 쉬워야 한다.
- 에러를 최소화해야 한다.
- 초반에 정한 비용에 맞춰 개발해야 한다.
- 정확한 결과가 도출되어야 한다.
- 원하는 시간에 원하는 기능을 수행할 수 있어야 한다.

**소프트웨어 공학의 목표**

- 소프트웨어의 생산성과 품질을 향상시킨다.
- 최소의 비용으로 단기간에 시스템에 적합한 소프트웨어를 개발하는 것이 소프트웨어 공학의 궁극적 목적이다.

# 2. 재공학

## **재공학**

**소프트웨어 재공학(Software Reengineering)의 개념**

- 소프트웨어 위기를 개발의 생산성이 아닌 유지보수의 생산성으로 해결하려는 방법을 의미한다.
- 현재의 시스템을 변경하거나 재구조화(Restructuring)하는 것이다.
- 재구조화는 재공학의 한 유형으로 사용자의 요구사항이나 기술적 설계의 변경 없이 프로그램을 개선하는 것이다.
- 소프트웨어 재공학 관점에서 가장 연관 깊은 유지보수 유형은 예방 유지보수(Preventive Maintenance)이다.

**재공학의 장점, 목표, 과정**

장점

- 개발 시간 및 비용 감소
- 품질 향상
- 생산성 향상
- 신뢰성 향상
- 구축 방법에 대한 지식의 공유
- 프로젝트 실패 위험 감소

목표

- 소프트웨어의 유지보수성 향상이 최우선
- 복잡한 시스템을 다루는 방법 구현, 다른 뷰의 생성, 잃어버린 정보의 복구 및 제거
- 재사용을 수월하게 하며 소프트웨어의 수명을 연장하기 위함.

과정

- 분석(Analysis) => 구성(Restructuring) => 역공학(Reverse Engineering) => 이식(Migration)

## **역공학**

**역공학의 개념**

- 소프트웨어를 분석하여 소프트웨어 개발 과정과 데이터 처리 과정을 설명하는 분석 및 설계 정보를 재발견하거나 다시 만들어내는 작업이다.
- 역공학의 가장 간단하고 오래된 형태는 재문서화라고 할 수 있다.

## **CASE(Computer Aided Software Engineering)**

**CASE**

- 소프트웨어 개발 과정에서 사용되는 요구분석, 설계, 구현, 검사 및 디버깅 과정을 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 작업이다.
- 자료 흐름도 등의 다이어그램을 쉽게 작성하게 해주는 소프트웨어 CASE 도구이다.
- 작업 과정 및 데이터 공유를 통해 작업자 간의 커뮤니케이션을 증대한다.

**CASE가 제공하는 기능**

- 개발을 신속하게 할 수 있고, 오류 수정이 쉬워 소프트웨어 품질이 향상된다.
- 소프트웨어 생명주기의 전체 단계를 연결해 주고 자동화시켜 주는 통합된 도구를 제공해주는 기술이다.
- 소프트웨어 시스템의 문서화 및 명세화를 위한 그래픽 기능을 제공한다.
- 소프트웨어 개발 단계의 표준화를 기할 수 있으며, 자료 흐름도 작성 기능을 제공한다.
- 모델들 사이의 모순 검사 기능을 제공하며 다양한 소프트웨어 개발 모형을 지원한다.
- 원천 기술 : 구조적 기법, 프로토타이핑 기술, 정보 저장소 기술

**CASE 사용의 장점**

- 소프트웨어 개발 기간 단축 및 개발 비용을 절약하여 소프트웨어 생산성을 향상시킨다.
- 자동화된 검사를 통해 소프트웨어 품질이 향상된다.
- 프로그램의 유지보수가 간편해지고 소프트웨어 모듈의 재사용성이 향상된다.
- 소프트웨어 개발 주기의 표준안 확입, 소프트웨어 개발 기법의 실용화, 문서화의 용이성 제공, 시스템 수정 및 유지보수 축소 등의 효과를 얻을 수 있다.

**CASE의 분류**

- 상위(Upper) CASE : 요구분석 및 설계 단계 지원
- 하위(Lower) CASE : 소스 코드 작성, 테스트, 문서화 과정 지원
- 통합(Integrate) CASE : 소프트웨어 개발 주기 전체 과정 지원

## **요구사항 분석을 위한 CASE 도구**

**요구사항 분석을 위한 CASE**

- 요구사항을 자동으로 분석하고, 요구사항 분석 명세서를 기술하도록 개발된 도구를 의미한다.
- 표준화와 보고를 통한 문서화 품질 개선, 변경이 주는 영향 추적의 용이성, 명세에 대한 유지보수 비용 축소, 교차 참조도와 보고서를 통한 결함, 생략, 불일치 등의 발견 용이성 등의 특징을 갖는다.
- DB가 모두에게 이용 가능하다는 점에서 분석자들 간의 적절한 조정 기능을 제공한다.

**요구사항 분석을 위한 CASE 도구**

- SADT(Structured Analysis and Design Technique) : SoftTech 사에서 개발한 것으로 시스템 정의, 소프트웨어 요구사항 분석, 시스템/소프트웨어 설계를 위해 널리 이용되어 온 구조적 분석 및 설계 도구이다. 구조적 요구분석을 하기 위해 블록 다이어그램을 채택한 자동화 도구다.
- REM(Software Requirements Engineering Methodolohy) = RSL/REVS : TRW 사가 우주 국방 시스템 그룹에 의해 실시간 처리 소프트웨어 시스템에서 요구사항을 명확히 기술하도록 할 목적으로 개발한 것으로, RSL과 REVS를 사용하는 자동화 도구이다.
  - RSL(Requirement Statement Language) : 요소, 속성, 관계, 구조들을 기술하는 요구사항 기술 언어이다.
  - REVS(Requirement Engineering and Validation System) : RSL로 기술된 요구사항들을 자동으로 분석하여 요구사항 분석 명세서를 출력하는 요구사항 분석기이다.

# 3. 소프트웨어 개발 방법론

## **소프트웨어 설계 방법론**

**소프트웨어 생명주기(Software Life Cycle)**

- 소프트웨어 제품의 개념 형성에서 시작하여 운용/유지보수에 이르기까지 변화의 모든 과정이다.
- 타당성 검토 => 개발 계획 => 요구사항 분석 => 설계 => 구현 => 테스트 => 운용 => 유지보수

**폭포수 모형(Waterfall Model)의 개요**

- 선형 순차적 모델이라고도 하며 Boehm이 제시한 고전적 생명주기 모형으로, 소프트웨어 개발 과정의 각 단계가 순차적으로 진행되는 모형이다.

**나선형 모형(Spiral Model)**

- Boehm이 제시하였으며, 반복적인 작업을 수행하는 점증적 생명주기 모형이다.
- 점증적 모형, 집중적 모형이라고도 하며 유지보수 과정이 필요 없다.
- 소프트웨어 개발 중 발생할 수 있는 위험을 관리하고 최소화하는 것이 목적이다.
- 나선을 따라서 돌아가면서 각 개발 순서를 반복하여 수행하는 점진적 방식으로 누락된 요구사항을 추가할 수 있다.

**하향식과 상향식 설계**

- 하향식 설계 : 소프트웨어 설계 시 제일 상위에 있는 Main User Function에서 시작하여 기능을 하위 기능들로 나눠 가면서 설계하는 방식이다.
- 상향식 설계 : 가장 기본적인 컴포넌트를 먼저 설계한 다음 이것을 사용하는 상위 수준의 컴포넌트를 설계하는 방식이다.

**프로토타입 모형(Prototype Model)의 개요**

- 실제 개발될 시스템의 견본(Prototype)을 미리 만들어 최종 결과물을 예측하는 모형이다.
- 개발이 완료되고 나서 사용을 하면 문제점을 알 수 있는 폭포수 모형의 단점을 보완하기 위한 모형으로 요구사항을 충실히 반영할 수 있다.

**HIPO(Hierarchy Input Process Output)**

- 입력, 처리, 출력으로 구성되는 시스템 분석 및 설계와 시스템 문서화용 기법이다.
- 일반적으로 가시적 도표(Visual Table of Contents), 총체적 다이어그램(Overview Diagram), 세부적 다이어그램(Detail Diagram)으로 구성된다.
- 구조도(가시적 도표, Visual Table of Contents), 개요, 도표(Index Diagram), 상세 도표(Detail Diagram)로 구성된다.
- 가시적 도표는 전체적인 기능과 흐름을 보여주는 구조이다.
- 기능과 자료의 의존 관계를 동시에 표현할 수 있다.
- 보기 쉽고 이해하기 쉬우며 유지보수가 쉽다.
- 하향식 소프트웨어 개발을 위한 문서화 도구이다.

**V-모델**

- 폭포수 모형에 시스템 검증과 테스트 작업을 강조한 모델이다.
- 세부적인 프로세스로 구성되어 있어서 신뢰도 높은 시스템 개발에 효과적이다.
- 개발 단계의 작업을 확인하기 위해 테스트 작업을 수행한다.
- 생명주기 초반부터 테스트 작업을 지원한다.
- 코드뿐만 아니라 요구사항과 설계 결과도 테스트할 수 있어야 한다.
- 폭포수 모형보다 반복과 재처리 과정이 명확하다.
- 테스트 작업을 단계별로 구분하므로 책임이 명확해진다.

## 애자일(Agile) 개발 방법론

**애자일(Agile) 개발방법론**

- 날렵한, 재빠른 이란 사전적 의미가 있다.
- 특정 방법론이 아닌 소프트웨어를 빠르고 낭비 없이 제작하기 위해 고객과의 협업에 초점을 두고 소프트웨어 개발 중 설계 변경에 신속히 대응하여 요구사항을 수용할 수 있다.
- 절차와 도구보다 개인과 소통을 중요시하고 고객과의 피드백을 중요하게 생각한다.
- 소프트웨어가 잘 실행되는데 가치를 두며, 소프트웨어 배포 시차를 최소화할 수 있다.
  - 특징 : 짧은 릴리즈와 반복, 점증적 설계, 사용자 참여, 문서 최소화, 비공식적인 커뮤니케이션 변화
  - 종류
    - 익스트림 프로그래밍(XP, eXtreame Programming)
    - 스크럼(SCRUM)
    - 린(Lean)
    - DSDM(Dynamic System Development Method, 동적 시스템 개발 방법론)
    - FDD(Feature Driven Development, 기능 중심 개발)
    - Crystal
    - ASD(Adaptive Software Development, 적응형 소프트웨어 개발방법론)
    - DAD(Disciplined Agile Delivery, 학습 애자일 배포)

**Ahile 선언문**

- 프로세스나 도구보다 개인과의 소통이 더 중요하다.
- 완벽한 문서보다 실행되는 소프트웨어가 더 중요하다.
- 계약 협상보다 고객과의 협업이 더 중요하다.
- 계획을 따르는 것보다 변경에 대한 응답이 더 중요하다.

## XP(eXtreme Programming)

**XP(eXtreme Programming)**

- 1999년 Kent Beck이 제안하였으며, 개발 단계 중 요구사항이 시시각각 변동이 심한 경우 적합한 방법론이다.
- 요구에 맞는 양질의 소프트웨어를 신속하게 제공하는 것을 목표로 한다.
- 요구사항을 모두 정의해 놓고 작업을 진행하는 것이 아니라, 요구사항이 변경되는 것을 적용하는 방식으로 예측성보다는 적응성에 더 높은 가치를 부여한 방법이다.
- 고객의 참여와 개발 과정의 반복을 극대화하여 생산성을 향상하는 방법이다.

**XP 핵심 가치**

- 소통(Communication) : 개발자, 관리자, 고객 간의 원활한 소통을 지향한다.
- 단순성(Simplicity) : 부가적 기능 또는 미사용 구조와 알고리즘은 배제한다.
- Feedback : 소프트웨어 개발에서 변화는 불가피하다. 이러한 변화는 지속적 테스트와 통합, 반복적 결함 수정 등 빠르게 피드백한다.
- 용기(Courage) : 고객 요구사항 변화에 능동적으로 대응한다.
- 존중(Respect) : 개발 팀원 간의 상호 존중을 기본으로 한다.

**XP Process**

| 용어             | 설명                                                                                                                                                                                                                                                                                                              |
| ---------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| User Story       | 일종의 요구사항으로 UML의 유즈케이스와 같은 목적으로 생성되나, 형식이 없고 고객에 의해 작성된다는 것이 다르다.                                                                                                                                                                                                    |
| Release Planning | 몇 개의 스토리가 적용되어 부분적으로 기능이 완료된 제품을 제공하는 것으로 부분/전체 개발 완료 시점에 대한 일정을 수립한다.                                                                                                                                                                                        |
| iteration        | 하나의 릴리즈를 세분화한 단위이며 1~3주 단위로 진행된다. 반복(iteration) 진행 중 새로운 스토리가 추가될 때 진행 중 반복(Iteration)이나 다음 반복에 추가될 수 있다.                                                                                                                                                |
| Acceptance Test  | 릴리즈 단위의 개발이 구현되었을 때 진행하는 테스트로, 사용자 스토리에 작성된 요구사항을 확인하여 고객이 직접 테스트한다.<br>오류가 발견되면 다음 반복(Iteration)에 추가한다. 테스트 후 고객의 요구사항이 변경되거나 추가되면 중요도에 따라 우선순위가 변경될 수 있다.<br>완료 후 다음 반복(Iteration)을 진행한다. |
| Small Release    | 릴리즈 단위를 기능별로 세분화하면 고객의 반응을 기능별로 확인할 수 있다.<br>최종 완제품일 때 고객에 의한 최종 테스트 진행 후 고객에 제공한다.                                                                                                                                                                     |

**XP의 12가지 실천사항(Practice)**

| 구분                 | 12 실천사항                    | 설명                                                                                                                                                                                                             |
| -------------------- | ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Fine Scale Feed-back | Pair Programing(짝 프로그래밍) | 두 사람이 짝이 되어 한 사람은 코딩을, 다른 사람은 검사를 수행하는 방식이다.<br>코드에 대한 책임을 공유하고, 비형식적인 검토를 수행할 수 있다.<br>코드 개선을 위한 리팩토링을 장려하며, 생산성이 떨어지지 않는다. |
|                      | Planning Game                  | 게임처럼 선수와 규칙, 목표를 두고 기획에 임한다.                                                                                                                                                                 |
|                      | Test Driven Development        | 실제 코드를 작성하기 전에 단위 테스트부터 작성 및 수행하며, 이를 기반으로 코드를 작성한다.                                                                                                                       |
|                      | Whole Team                     | 개발 효율을 위해 고객을 프로젝트 팀원으로 상주시킨다.                                                                                                                                                            |
| Continuous Process   | Continuous Integration         | 상시 빌드 및 배포를 할 수 있는 상태로 유지한다.                                                                                                                                                                  |
|                      | Design Improvement             | 기능 변경 없이 중복성/복잡성 제거, 커뮤니케이션 향상, 단순화, 유연성 등을 위한 재구성을 수행한다.                                                                                                                |
|                      | Small Releases                 | 짧은 주기로 잦은 릴리즈를 함으로써 고객이 변경사항을 볼 수 있게 한다.                                                                                                                                            |
| Shared Understanding | Coding Standards               | 소스 코드 작성 포맷과 규칙들을 표준화된 관례에 따라 작성한다.                                                                                                                                                    |
|                      | Collective Code Ownership      | 시스템에 있는 소스 코드는 팀의 모든 프로그래머가 누구든지 언제라도 수정할 수 있다.                                                                                                                               |
|                      | Simple Design                  | 가능한 가장 간결한 디자인 상태를 유지한다.                                                                                                                                                                       |
|                      | System Metaphor                | 최종적으로 개발되어야 할 시스템의 구조를 기술한다.                                                                                                                                                               |
| Programmer Welfare   | Sustainable Pace               | 일주일에 40시간 이상 작업 금지. 2주 연속 오버타임을 금지한다.                                                                                                                                                    |

**효과적인 프로젝트 관리를 위한 3대 요소**

- 사람(People) - 인적 자원
- 문제(Problem) - 문제 인식
- 프로세스(Process) - 작업 계획

# 4. SCRUM

3218
