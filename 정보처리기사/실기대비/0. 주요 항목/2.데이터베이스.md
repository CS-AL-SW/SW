# 2. 데이터베이스 (with SQL)

목차<br>
[데이터베이스 용어](#데이터베이스-용어)<br>
[자료구조](#자료구조)<br>
[정렬](#정렬)<br>
[데이터베이스 설계 단계](#데이터베이스-설계-단계)<br>
[데이터베이스 정규화](#데이터베이스-정규화)<br>
[데이터베이스 용어]()<br>

## 데이터베이스 용어

### 릴레이션 (DB 테이블)

- 관계형 데이터베이스에서 정보를 구분하여 저장하는 기본 단위
- 릴레이션은 DB 테이블이며, 흔히 개발을 할 때 DB 설계를 하게 되는데 ERD(Entity Relationship Diagram)를 구성하게 된다.

**특징**

- 한 릴레이션에는 똑같은 튜플(Tuple)이 포함될 수 없다. 릴레이션에 포함된 튜플들은 모두 상이하다.
- 한 릴레이션에 포함된 튜플 사이에는 순서가 없다.
- 튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변한다.
- 릴레이션 스키마를 구성하는 속성들 간의 순서는 중요하지 않다.
- 속성의 유일한 식별을 위해 속성의 명칭은 유일해야 하지만, 속성을 구성하는 값은 동일한 값이 있을 수 있다.
- 릴레이션을 구성하는 튜플을 유일하게 식별하기 위해 속성들의 부분집합 키(Key)로 설정한다.
- 속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자 값만을 저장한다.

### 구성

| 속성1         | 속성2 | 속성3 | 속성4 |
| ------------- | ----- | ----- | ----- |
| 튜플1(레코드) | -     | -     | -     |
| 튜플2(레코드) | -     | -     | -     |
| 튜플3(레코드) | -     | -     | -     |
| 튜플4(레코드) | -     | -     | -     |
| 튜플5(레코드) | -     | -     | -     |

### 속성(Attribute)

- 하나의 릴레이션은 현실세계의 어떤 개체(Entity)를 표현하고 저장하는데 사용된다. 이때 개체는 사물이 될 수도 있고 추상적인 개념이 될 수도 있다.
- 속성은 내가 저장하고 싶은 개체의 항목들이다. (ex. 고객명, 고유번호, 전화번호, 집 주소 등)
- 하나의 열은 하나의 속성 정보를 표시한다.
- 속성 또한 고유한 이름을 가지고 있어 동일한 릴레이션 내에서는 같은 이름의 속성이 존재할 수 없다.

### 차수(Degree) - 열(column)

- 한 릴레이션 안에 있는 속성 수를 차수라고 한다.
- 즉, 유효한 릴레이션의 최소 차수는 1이다.
- 모든 릴레이션은 적어도 하나 이상의 속성(Attribute)을 갖고 있고, 위의 테이블(릴레이션)에서 차수는 4임을 알 수 있다.

### 튜플(Tuble, 레코드)

- 릴레이션의 각 행을 레코드라고 한다.
- 공식적으로 튜플이라고 부른다.

### 카디날리티(Cardinality) - 행(row)

- 릴레이션 튜플의 개수이다.
- 아직 데이터가 삽입되지 않은 테이블의 경우 카디날리티는 차수와 다르게 0의 값을 가질 수 있다.
- 카디날리티는 시간이 지남에 따라 값이 계속해서 변화한다.

### 도메인(Domain)

- 릴레이션에 포함된 속성들이 각각 가질 수 있는 값들의 집합이다.
- 관계형 이론에서 도메인은 실제로는 구현이 어렵기 때문에 대부분의 DBMS에서 도메인이란 속성에 대응하는 컬럼에 대한 데이터 타입(DataType)과 길이를 의미한다.
- "두 속성의 도메인이 같다"라는 것은 두 속성의 데이터 타입과 길이가 같다는 것을 의미한다.
- 정의된 도메인명은 일반적인 데이터 타입처럼 사용할 수 있다.

### 스키마(Schema)

- 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터의 집합이다.
- 데이터베이스를 구성하는 데이터 개체(Entity), 속성(Attribute), 관계(Relationship) 및 데이터 조작 시 데이터 값들이 갖는 제약 조건 등에 관해 전반적으로 정의한다.
- 사용자의 관점에 따라 외부 스키마, 개념 스키마, 내부 스키마로 나눠진다.
  - 외부 스키마(External Schema)
    - 사용자나 응용 프로그래머가 접근할 수 있는 정의를 기술한다.
  - 개념 스키마(Conceptual Schema)
    - 데이터베이스 전체를 정의한 것으로 데이터 개체, 관계, 제약조건, 접근 권한, 무결성 규칙 등을 명세한 것이다.
    - 범기관적 입장에서 데이터베이스를 정의한다.
  - 내부 스키마(Internal Schema)
    - 데이터의 실제 저장 방법을 기술한다.
    - 물리적 저장 장치의 입장에서 본 데이터베이스 구조로써 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타낸다.

**외부 스키마**

| 학적과 |      |      |          |      |
| :----: | :--: | :--: | :------: | :--: |
|  학번  | 이름 | 학과 | 수강과목 | 성적 |
| 학생과 |      |      |          |      |
|  학번  | 이름 | 학과 |   성별   | 주소 |

**개념 스키마**

|          | 학생 DB |               |
| :------- | :-----: | ------------: |
| 학번     |         |    integer(8) |
| 이름     |         | character(10) |
| 학과     |         | character(11) |
| 성별     |         |  character(2) |
| 주소     |         | character(25) |
| 수강과목 |         | character(14) |
| 성적     |         |    integer(3) |

**내부 스키마**

|                                 |          |     |                 |                       |
| :------------------------------ | :------: | :-: | :-------------: | :-------------------: |
| STORED - STUDENT(학생개체 명세) |          |     | LENGTH=73(크기) |                       |
| 학번(저장필드 ↓)                | BYTE(8)  |     |    OFFSET=0     | INDEX=STX(인덱스정보) |
| 이름                            | BYTE(10) |     |    OFFSET=8     |                       |
| 학과                            | BYTE(11) |     |    OFFSET=18    |                       |
| 성별                            | BYTE(2)  |     |    OFFSET=29    |                       |
| 주소                            | BYTE(25) |     |    OFFSET=31    |                       |
| 수강 과목                       | BYTE(14) |     |    OFFSET=56    |                       |
| 성적                            | BYTE(3)  |     |    OFFSET=70    |                       |

## 논리모델 vs 물리모델

| 논리모델           | 물리모델       |
| ------------------ | -------------- |
| 엔티티(Entity)     | 테이블(Table)  |
| 속성(Attribute)    | 컬럼(Column)   |
| 관계(Relation)     | 관계(Relation) |
| 키 그룹(Key Group) | 인덱스(Index)  |

## 자료구조

### 선형 자료 구조

**리스트**

- 선형 리스트(Linear List)
  - 배열(Array)과 같이 연속되는 기억 장소에 저장되는 리스트
  - 가장 간단한 데이터 구조 중 하나로, 데이터 항목을 추가/삭제하는 것이 불편함.
- 연결 리스트(Linked List)
  - 노드의 포인터 부분을 서로 연결시킨 리스트로, 연속적인 기억 공간이 없어도 저장이 가능함.
  - 노드의 삽입/삭제가 용이하며, 포인터를 위한 추가 공간이 필요하므로 기억 공간이 많이 소요된다.

**스택(Stack)**

- 후입선출(Last In First Out - PUSH and POP)
- 리스트의 한쪽 끝에서만 자료의 삽입과 삭제가 이뤄지는 자료 구조
- 응용분야: 인터럽트 처리, 수식의 계산, 0-주소 지정 방식, 재귀호출, 후위 표현(Post-fix expression)의 연산, 깊이 우선 탐색(DFS)

**큐(Queue)**

- 선입선출(Fist In First Out)
- 자료의 삽입은 선형 리스트의 한쪽 끝에서, 제거 작업은 다른 쪽 끝에서 수행되는 자료 구조
- 응용분야: 운영체제의 작업 스케줄링 등

**덱(Deque)**

- 자료의 삽입과 삭제가 리스트의 양쪽 끝에서 이루어지는 두 개의 포인터를 사용하는 자료 구조.
- 스택과 큐를 복합한 형태
- 입력 제한 덱을 Scroll, 출력 제한 덱을 Shelf라고 함.

### 비선형 자료 구조

**트리**

- 그래프(Graph)의 특수한 형태로써 노드(Node)와 브랜치(Branch)를 이용해 사이클을 이루지 않도록 구성한 자료 구조

**이진 트리**

- 차수(Degree)가 2 이하인 노드들로만 구성된 트리
- 이진 트리의 레벨 n에서 최대 노드의 수 : 2ⁿ-1
- 이진 트리의 구조
  - 정이진 트리 : 첫 번째 레벨부터 마지막 레벨까지 모두 2개씩 채워진 트리
  - 전이진 트리 : 전이진 트리에서 한쪽 방향 노드가 아예 존재하지 않는 트리
  - 사향 이진 트리 : 근노드로부터 한쪽 방향으로만 기울어진 트리
- 이진 트리의 운행법(Traversal)
  - 전위(Preorder) 운행 (+AB) : Root => Left => Right
  - 중위(Inorder) 운행 (A+B) : Left => Root => Right
  - 후위(Postorde) 운행 (AB+) : Left => Right => Root

**그래프**

- 정점(Vertex)과 간선(Edge)의 집합으로 이루어지는 자료 구조
- 표현 방법 : 인접 행렬(Adjacency Matrix)
- 신장 트리(Spanning Tree) : 간선들이 사이클을 이루지 않도록 정점들을 연결시킨 그래프
- 종류 : 방향 그래프, 무방향 그래프, 완전 그래프, 부 그래프
- n개의 노트로 구성된 무방향 그래프의 최대 간선 수는 n(n-1)/2개
- 제어 흐름 그래프에서 순환 복잡도 : V(G) - E(화살표 수) - N(노드 수) + 2
- 인접 행렬(Adjacency Matrix)
  - 방향 그래프에서 ViVj 관계를 나타내는 행렬의 원소를 Aij라고 할 때, 방향 간선이 있으면 행렬의 Aij = 1, 방향 간선이 없으면 행렬의 Aij = 0으로 나타낸다.
  - 무방향 그래프에서 Vi와 Vj가 서로 인접하면 Aij = 1, 서로 인접하지 않으면 Aij = 0으로 나타낸다.
  - 여기서 i, j는 첨자 (A₃의 3과 같음)

### 정렬

- 정렬 알고리즘 선택 시 고려사항 : 데이터의 양, 초기 데이터의 배열 상태, 키 값들의 분포 상태, 사용 컴퓨터 시스템의 특성
- 종류 : 내부 정렬(장치에서 정렬이 이루어짐), 외부 정렬(보조 기억 장치에서 이루어짐)

**내부 정렬**

- 삽입 정렬(Insertion Sort)
  - 정렬된 파일에 하나의 레코드를 순서에 따라 삽입시켜 정렬하는 방법
- 선택 정렬(Selection Sort)
  - n개의 레코드 중에서 최소값(또는 최대값)을 찾아 1st 레코드 위치에 놓고, 나머지 (n-1)개의 레코드 중에서 최소값(또는 최대값)을 찾아 2nd 레코드 위치에 놓는 방법을 반족하여 정렬하는 방법.
  - 최대, 최소, 평균 시간 복잡도: O(n log₂ n)
- 병합 정렬(2-Way Merge Sort)
  - 두 개의 키들을 한 쌍으로 하여 각 쌍에 대해 순서를 정한다.
  - 순서대로 정렬된 각 쌍의 키들을 합병하여 하나의 정렬된 서브 리스트로 만든다.
  - 최대, 최소, 평균 시간 복잡도 : O(n log₂ n)
- 퀵 정렬(Quick Sort)
  - 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어가면서 정렬하는 방법으로, 키를 기준으로 작은 값은 왼쪽에 큰 값은 오른쪽에 모이도록 서로 교환시키는 부분 교환 정렬법.
  - 최대, 최소, 평균 시간 복잡도 : O(n log₂ n), 약=O(n²)
- 힙 정렬(Heap Sort)
  - 전이진 트리를 이용하여 정렬하는 방법
  - 정렬한 입력 레코드들로 힙을 구성하고 가장 큰 키값을 갖는 루트 노드를 제거하는 과정을 반복하여 정렬하는 기법
  - 평균 수행 시간 복잡도는 O(n log₂ n)이고, 최악의 수행 시간 복잡도는 O(log₂ n)이다.
  - 입력 자료의 레코드를 완전 이진 트리(Complete Binary Tree)로 구성한다.

### 데이터베이스 설계 단계

1. 요구사항 분석
   - 데이터베이스 사용자로부터 요구조건 수집과 요구조건 명세서를 작성한다.
2. 개념적 설계
   - 목표 DBMS에 독립적인 개념 스키마를 설계한다.
   - 개념 스키마 모델링(ERD)과 트랜잭션 모델링을 병행 수행하낟.
3. 논리적 설계
   - 목표 DBMS에 종속적인 논리적 스키마를 설계한다.
   - 스키마의 평가 및 정제를 한다.
   - 논리적 데이터 모델로 변환 및 트랜잭션 인터페이스를 설계한다.
4. 물리적 설계
   - 목표 DBMS에 종속적인 물리적 구조를 설계한다.
   - 저장 레코드 양식 설계와 레코드 집중의 분석/설계, 엑세스 경로 인덱싱, 클러스터링, 해싱 등의 설계가 포함된다.
   - 접근 경로 설계 및 트랜잭션 세부 설계를 한다.
5. 데이터베이스 구현
   - 목표 DBMS의 DDL(데이터 정의어)로 스키마를 작성한다.
   - 데이터베이스에 등록 후 트랜잭션을 작성한다.

### 데이터베이스 정규화

**정규화(Normalization)의 개념**

- 함수적 종속성 등의 종속성 이론을 이용하여 잘못 설계된 관계형 스키마를 더 작은 속성의 세트로 쪼개어 바람직한 스키마로 만들어 가는 과정
- 좋은 데이터베이스 스키마를 생성하고 불필요한 데이터의 중복을 방지하여 정보 검색을 용이하게 할 수 있도록 허용함.

**정규화의 목적**

- 데이터 구조의 안정성 최대화
- 중복 데이터의 최소화
- 수정 및 삭제 시 이상 현상 최소화
- 테이블 불일치 위험 간소화

**이상 현상**

- 릴레이션 조작 시 데이터들이 불필요하게 중복되어 예기치 않게 발생하는 곤란한 현상을 의미
- 종류
  - 삽입 이상(Insertion Anomaly)
    - 데이터를 삽입할 때 불필요한 데이터가 함께 삽입되는 현상
  - 삭제 이상(Deletion Anomaly)
    - 릴레이션의 한 튜플을 삭제함으로써 연쇄 삭제로 인해 정보의 손실을 발생시키는 현상
  - 갱신 이상(Update Anomaly)
    - 튜플 중에서 일부 속성을 갱신함으로써 정보의 모순성이 발생하는 현상

**정규화 과정**

비정규 릴레이션 => 1NF(도메인이 원자값) => 2NF(부분적 함수 종속 제거) => 3NF(이행적 함수 종속 제거) => BCNF(결정자이면서 후보키가 아닌 함수 종속 제거) => 4NF(다치 종속 제거) => 5NF(조인 종속성 제거)

**1정규형**

- 어떤 릴레이션에 속한 모든 도메인이 원자값(Atomic Value)만으로 되어 있는 릴레이션이다.
- 하나의 속성만 있어야 하고 반복되는 속성은 별도 테이블로 분리한다.

|   국가   |    도시     | 1정규형-> |   국가   |  도시  |
| :------: | :---------: | :-------: | :------: | :----: |
| 대한민국 |  서울,부산  |           | 대한민국 |  서울  |
|   미국   | 워싱턴 뉴욕 |           | 대한민국 |  부산  |
|   중국   |   베이징    |           |   미국   | 워싱턴 |
|          |             |           |   미국   |  뉴욕  |
|          |             |           |   중국   | 베이징 |

**2정규형**

- 1정규형을 만족하고, 내재된 부분 함수적 종속을 제거한다.
- 기본키가 아닌 애트리뷰트 모두가 기본키에 완전 함수 종속이 되도록 부분 함수적 종속에 해당하는 속성을 별도의 테이블로 분리한다.

**3정규형**

- 1, 2정규형을 만족하고, 이행적 함수 종속(A->B,B->A->C)을 제거한다.

**BCNF(Boyce-Code Normal Form - 보이스/코드)정규형**

- 1, 2, 3정규형을 만족하고, 결정자가 후보키가 아닌 함수 종속이 제거되면 보이스/코드 정규형에 속한다.
- 후보키를 여러 개 가지고 있는 릴레이션에서 발생할 수 있는 이상 현상을 해결하기 위해 3정규형보다 좀 더 강력한 제약조건을 적용한다.
- 보이스/코드 정규형에 속하는 모든 릴레이션은 3정규형에 속하지만, 3정규형에 속하는 모든 릴레이션이 보이스/코드 정규형에 속하지는 않는다.

**4정규형**

- 1, 2, 3, BCNF 정규형을 만족하고, 다가(다치) 종속을 제거한다.

**5정규형**

- 1, 2, 3, BCNF, 4정규형을 만족하고, 후보키를 통하지 않은 조인 종속을 제거한다.

## **반정규화**

- 정규화를 통하여 정합성과 데이터 무결성이 보장되지만, 테이블의 개수가 증가함에 따라 테이블 간의 조인이 증가하여 조회 성능이 떨어질 수 있는데, 이렇게 정규화된 엔티티, 속성, 관계에 대해 시스템의 성능 향상과 개발(Development) 및 운영(Maintenance)의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법을 의미한다.
- 반정규화 기법 : 테이블 반정규화, 컬럼 반정규화, 관계 반정규화
- 테이블 반정규화 기법 : 테이블 병합, 테이블 분할, 테이블 추가
- 테이블 추가 반정규화 유형 : 중복 테이블 추가, 집계 테이블 추가, 진행 테이블 추가, 부분 테이블 추가
