# C 기초 4

<p style="color: #333333; text-align: start;" data-ke-size="size16"><span style="color: #000000;">목차</span></p>
<p style="color: #333333; text-align: start;" data-ke-size="size16"><span style="color: #000000;">1. 포인터와 1차원 배열</span></p>
<p style="color: #333333; text-align: start;" data-ke-size="size16"><span style="color: #000000;">2. 포인터와 2차원 배열</span></p>
<p style="color: #333333; text-align: start;" data-ke-size="size16"><span style="color: #000000;">3. 포인터와 문자 배열</span></p>
<p style="color: #333333; text-align: start;" data-ke-size="size16"><span style="color: #000000;">4. 포인터와 문자열 배열</span><span style="color: #000000;"></span></p>
<p style="color: #333333; text-align: start;" data-ke-size="size16"><span style="color: #000000;">5. 함수 심화(Call my Value, Call my Reference)</span></p>
<p style="color: #333333; text-align: start;" data-ke-size="size16"><span style="color: #000000;">6. 구조체</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3">
<p style="color: #333333; text-align: start;" data-ke-size="size16">1. 포인터와 1차원 배열</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">우선 배열의 이름은 배열의 시작주소이다.</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">&nbsp;</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">아래 예문을 보자.</p>
<pre id="code_1683420336019" class="csharp" data-ke-language="csharp" data-ke-type="codeblock"><code class="hljs"><span class="hljs-meta">#include &lt;stdio.h&gt;</span>

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> {
<span class="hljs-built_in">int</span> array[<span class="hljs-number">3</span>] = { <span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span> };
printf(<span class="hljs-string">"%x %x %x \n"</span>, array, array + <span class="hljs-number">0</span>, &amp;array[<span class="hljs-number">0</span>]); <span class="hljs-comment">//배열 0번째 요소의 주소 출력</span>
printf(<span class="hljs-string">"%d %d %d \n"</span>, _array, _(array + <span class="hljs-number">0</span>), \*&amp;array[<span class="hljs-number">0</span>]); <span class="hljs-comment">//뱌욜 0번째 요소의 값 10 출력</span>
}</code></pre>

<p style="background-color: #ffffff; color: #000000; text-align: start;" data-ke-size="size16">*array는 array(배열 이름) 주소가 가리키는 값인 10이 출력된다</p>
<p style="background-color: #ffffff; color: #000000; text-align: start;" data-ke-size="size16">*(array+0)은 array주소에 0칸 이동한 주소가 가리키는 값인 10이 출력된다</p>
<p style="background-color: #ffffff; color: #000000; text-align: start;" data-ke-size="size16">*&amp;가 동시에 있으면 생략이 가능하다.</p>
<p style="background-color: #ffffff; color: #000000; text-align: start;" data-ke-size="size16">즉 *&amp;arr[0]=array[0] 따라서 역시 배열의 0번째 인덱스인 10이 출력된다</p>
<p style="background-color: #ffffff; color: #000000; text-align: start;" data-ke-size="size16">&nbsp;</p>
<p style="background-color: #ffffff; color: #000000; text-align: start;" data-ke-size="size16">결국 array==array+0==&amp;array[0]이라는 의미이다</p>
<p style="background-color: #ffffff; color: #000000; text-align: start;" data-ke-size="size16">&nbsp;</p>
<p style="background-color: #ffffff; color: #000000; text-align: start;" data-ke-size="size16">다만 여기서 주의점은 int형 배열이라 요소 1개의 크기는 4바이트이고 array,array+0, &amp;array[0]으로 출력되는 값은 동일하지만 array만 0번째 요소가 아니라 배열 전체를 가리키기 때문에 12바이트(int형이 3칸있으니 12바이트)가 된다</p>
<p style="background-color: #ffffff; color: #000000; text-align: start;" data-ke-size="size16">&nbsp;</p>
<p style="background-color: #ffffff; color: #000000; text-align: start;" data-ke-size="size16">다음과 같이 포인터변수 p에 array(배열이름)으로 배열의 시작주소를 저장하면 포인터변수를 배열처럼 사용할 수 있다</p>
<p style="background-color: #ffffff; color: #000000; text-align: start;" data-ke-size="size16">아래 예문은 위의 예문과 결과값이 100% 동일하다</p>
<pre id="code_1683421019523" class="csharp" data-ke-language="csharp" data-ke-type="codeblock"><code class="hljs"><span class="hljs-meta">#include &lt;stdio.h&gt;</span>

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> {
<span class="hljs-built_in">int</span> array[<span class="hljs-number">3</span>] = { <span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span> };
<span class="hljs-built_in">int</span>\* p = array; <span class="hljs-comment">//포인터 변수에 배열의 시작 주소를 저장</span>

    printf(<span class="hljs-string">"%x %x %x \n"</span>,p,p+<span class="hljs-number">0</span>,&amp;p[<span class="hljs-number">0</span>]); <span class="hljs-comment">//배열 0번째 요소의 주소 출력</span>
    printf(<span class="hljs-string">"%d %d %d \n"</span>, *p,*(p+<span class="hljs-number">0</span>),*&amp;p[<span class="hljs-number">0</span>]); <span class="hljs-comment">//배열 0번째 요소의 값 출력</span>

}</code></pre>

<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="background-color: #f3c000;">다 필요없고 위 같은 경우 포인터변수 p랑 array랑 똑같다고 생각해주면 된다</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3">
<p style="background-color: #ffffff; color: #000000; text-align: start;" data-ke-size="size16">2. 포인터와 2차원 배열</p>
<p style="background-color: #ffffff; color: #000000; text-align: start;" data-ke-size="size16">1차원배열에서는 *(array+i)==array[i]==*&amp;array[i]는 값이라고 배웠는데</p>
<p style="background-color: #ffffff; color: #000000; text-align: start;" data-ke-size="size16">2차원 배열에서는 <span style="background-color: #ffffff; color: #000000; text-align: start;"><span>&nbsp;</span>*(array+i)==array[i]==*&amp;array[i]가 주소를 가리킨다</span></p>
<p style="background-color: #ffffff; color: #000000; text-align: start;" data-ke-size="size16">&nbsp;</p>
<p style="background-color: #ffffff; color: #000000; text-align: start;" data-ke-size="size16"><span style="background-color: #ffffff; color: #000000; text-align: start;">int array[2][3] = { 10,20,30,40,50,60 }라는 2차원 배열이 있을 때 테이블 같은 구조를 연상하지만 실제는 일직선으로 나란히 돼있는 것을 일단 상기시키고 가보도록 하자.</span></p>
<p></p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="396" data-origin-height="98"><span data-url="https://blog.kakaocdn.net/dn/dTJP36/btsd4Gne064/ESXncJjnJ1Saop0ylk7XW1/img.png" data-lightbox="lightbox"><img src="https://blog.kakaocdn.net/dn/dTJP36/btsd4Gne064/ESXncJjnJ1Saop0ylk7XW1/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdTJP36%2Fbtsd4Gne064%2FESXncJjnJ1Saop0ylk7XW1%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" width="473" height="117" data-origin-width="396" data-origin-height="98"></span></figure>
<p></p>
<p data-ke-size="size16"><span style="background-color: #ffffff; color: #000000; text-align: start;">2차원배열에서도 1차원배열에서 처럼 &amp;array[0][0] 이런식으로 하면 각 배열의 요소의 주소, *&amp;array[0][0] 하면 각 배열의 요소의 값이 잘 출력된다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="background-color: #ffffff; color: #000000; text-align: start;">그렇다면 아래 예문은 어떤 결과가 나올까?&nbsp;</span></p>
<pre id="code_1683424973718" class="csharp" data-ke-language="csharp" data-ke-type="codeblock"><code class="hljs"><span class="hljs-meta">#include &lt;stdio.h&gt;</span>

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> {
<span class="hljs-built_in">int</span> array[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = { <span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>,<span class="hljs-number">60</span> };

    (<span class="hljs-number">1</span>)printf(<span class="hljs-string">"%x\n"</span>, array);
    (<span class="hljs-number">2</span>)printf(<span class="hljs-string">"%x\n"</span>, array[<span class="hljs-number">0</span>]);
    (<span class="hljs-number">3</span>)printf(<span class="hljs-string">"%x\n"</span>, *(array + <span class="hljs-number">0</span>));
    (<span class="hljs-number">4</span>)printf(<span class="hljs-string">"%x\n"</span>, &amp;array[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);

    (<span class="hljs-number">5</span>)printf(<span class="hljs-string">"%x\n"</span>, array+<span class="hljs-number">1</span>);
    (<span class="hljs-number">6</span>)printf(<span class="hljs-string">"%x\n"</span>, array[<span class="hljs-number">1</span>]);
    (<span class="hljs-number">7</span>)printf(<span class="hljs-string">"%x\n"</span>, *(array + <span class="hljs-number">1</span>));
    (<span class="hljs-number">8</span>)printf(<span class="hljs-string">"%x\n"</span>, &amp;array[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);


    (<span class="hljs-number">9</span>)printf(<span class="hljs-string">"%d\n"</span>,<span class="hljs-keyword">sizeof</span>(&amp;array[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]));  <span class="hljs-comment">//4 출력</span>
    (<span class="hljs-number">10</span>)printf(<span class="hljs-string">"%d\n"</span>, <span class="hljs-keyword">sizeof</span>(array[<span class="hljs-number">0</span>]));  <span class="hljs-comment">//12 출력</span>
    (<span class="hljs-number">11</span>)printf(<span class="hljs-string">"%d\n"</span>, <span class="hljs-keyword">sizeof</span>(array));  <span class="hljs-comment">//24 출력</span>

}</code></pre>

<p data-ke-size="size16">(1)~(4)까지는 array[0][0]의 주소를 출력하고</p>
<p data-ke-size="size16">(5)~(8)까지는 array[1][0]의 주소를 출력한다</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">결과값은 동일하지만 4번과 8번의 경우는 arr[0][0], array[1][0] 처럼 특정한 요소의 주소를 가리키지만 나머지는 아래 그림과 같이 특정행을 가리킨다.&nbsp;</p>
<p data-ke-size="size16">따라서 (9)는 특정요소를 가리키므로 4가 출력되고 (10)은 행을 가리키므로 12가 출력되고 (11)은 배열 전체를 가리켜서 24가 출력된다&nbsp;</p>
<p></p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="391" data-origin-height="139"><span data-url="https://blog.kakaocdn.net/dn/cwhuuB/btsedaOvhbO/rZ37yUVNamzuL6OuiKCQKK/img.png" data-lightbox="lightbox"><img src="https://blog.kakaocdn.net/dn/cwhuuB/btsedaOvhbO/rZ37yUVNamzuL6OuiKCQKK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcwhuuB%2FbtsedaOvhbO%2FrZ37yUVNamzuL6OuiKCQKK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="391" data-origin-height="139"></span></figure>
<p></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">*(array + 0)이 형태만 조금 더 살펴 보자</p>
<p data-ke-size="size16">먼저 array는 배열 전체를 가리키지만 위치는 array[0][0] 시작주소에 가 있다</p>
<p></p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="467" data-origin-height="186"><span data-url="https://blog.kakaocdn.net/dn/lHtYg/btsd0SoqMFE/0Kk6t01oxhhmYfebmvHl3K/img.png" data-lightbox="lightbox"><img src="https://blog.kakaocdn.net/dn/lHtYg/btsd0SoqMFE/0Kk6t01oxhhmYfebmvHl3K/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FlHtYg%2Fbtsd0SoqMFE%2F0Kk6t01oxhhmYfebmvHl3K%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="467" data-origin-height="186"></span></figure>
<p></p>
<p data-ke-size="size16">두번째 *(array+0)는 array에서 +0한 곳의 값을 읽는 것인데 2차원배열에서는 이 값이 행의 주소를 가리킨다</p>
<p data-ke-size="size16">배열에서 특정 행을 가리키지만 위치는 array[0][0] 시작주소에 가 있다</p>
<p></p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="457" data-origin-height="168"><span data-url="https://blog.kakaocdn.net/dn/b6C9i2/btsd5YgNJhO/EJ45aph3urFSrIxP3WlZpK/img.png" data-lightbox="lightbox"><img src="https://blog.kakaocdn.net/dn/b6C9i2/btsd5YgNJhO/EJ45aph3urFSrIxP3WlZpK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb6C9i2%2Fbtsd5YgNJhO%2FEJ45aph3urFSrIxP3WlZpK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="457" data-origin-height="168"></span></figure>
<p></p>
<p data-ke-size="size16">세번째 array[0]+0은 배열에서 특정 행의 특정 요소 가리키지만 역시 위치는 array[0][0] 시작주소에 가 있다</p>
<p data-ke-size="size16">따라서&nbsp;</p>
<p></p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="441" data-origin-height="169"><span data-url="https://blog.kakaocdn.net/dn/cZlO7D/btsedb7IKox/tEuJVw3FnLMYBsvjQAK2RK/img.png" data-lightbox="lightbox"><img src="https://blog.kakaocdn.net/dn/cZlO7D/btsedb7IKox/tEuJVw3FnLMYBsvjQAK2RK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcZlO7D%2Fbtsedb7IKox%2FtEuJVw3FnLMYBsvjQAK2RK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="441" data-origin-height="169"></span></figure>
<p></p>
<p data-ke-size="size16">모두 출력되는 값은 동일하지만 크기는 다르다</p>
<p data-ke-size="size16">이해한 것을 토대로 아래 출력결과를 예상해보자.</p>
<pre id="code_1683427191797" class="csharp" data-ke-language="csharp" data-ke-type="codeblock"><code class="hljs"><span class="hljs-meta">#include &lt;stdio.h&gt;</span>

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> {
<span class="hljs-built_in">int</span> array[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = { <span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>,<span class="hljs-number">60</span> };

    (<span class="hljs-number">1</span>)printf(<span class="hljs-string">"%d\n"</span>, <span class="hljs-keyword">sizeof</span>(array));
    (<span class="hljs-number">2</span>)printf(<span class="hljs-string">"%d\n"</span>, <span class="hljs-keyword">sizeof</span>(array[<span class="hljs-number">0</span>]+<span class="hljs-number">0</span>));
    (<span class="hljs-number">3</span>)printf(<span class="hljs-string">"%d\n"</span>, <span class="hljs-keyword">sizeof</span>(*(array + <span class="hljs-number">0</span>)));
    (<span class="hljs-number">4</span>)printf(<span class="hljs-string">"%d\n"</span>, <span class="hljs-keyword">sizeof</span>( &amp; array[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]));
    }</code></pre>

<div style="background-color: #fafafa; color: #333333;" data-ke-type="moreLess" data-text-more="정답보기" data-text-less="접기"><a class="btn-toggle-moreless">정답보기</a>
<div class="moreless-content">
<p data-ke-size="size16">(1)은 array가 배열의 전체를 가리키므로 24</p>
<p data-ke-size="size16">(2)는 array[0]이 2차원배열의 0번째 행을 가리키고 0번째 행의 0번째 요소를 가리키므로 4출력</p>
<p data-ke-size="size16">(3)는 array는 배열의 전체를 가리키지만 array+0을 함으로써 0번째 행을 가리키게 돼 12가 출력된다(2차원 배열에서는 배열이름의 주소에 대한 값이 특정행의 주소를 가리키게 된다)</p>
<p data-ke-size="size16">(4)는 0행 0열의 주소를 가리키므로 4가 출력된다</p>
<pre id="code_1683427268436" class="csharp" data-ke-language="csharp" data-ke-type="codeblock"><code class="hljs"><span class="hljs-meta">#include &lt;stdio.h&gt;</span>

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> {
<span class="hljs-built_in">int</span> array[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = { <span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>,<span class="hljs-number">60</span> };

    printf(<span class="hljs-string">"%d\n"</span>, <span class="hljs-keyword">sizeof</span>(array));  <span class="hljs-comment">//24출력</span>
    printf(<span class="hljs-string">"%d\n"</span>, <span class="hljs-keyword">sizeof</span>(array[<span class="hljs-number">0</span>]+<span class="hljs-number">0</span>)); <span class="hljs-comment">//4출력</span>
    printf(<span class="hljs-string">"%d\n"</span>, <span class="hljs-keyword">sizeof</span>(*(array + <span class="hljs-number">0</span>))); <span class="hljs-comment">//12출력</span>
    printf(<span class="hljs-string">"%d\n"</span>, <span class="hljs-keyword">sizeof</span>( &amp;array[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])); <span class="hljs-comment">//4출력</span>
    }</code></pre>

</div>
</div>
<p></p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="541" data-origin-height="218"><span data-url="https://blog.kakaocdn.net/dn/cQ8Sm7/btseda8ML1R/mtYZKMxBX2k54JwJe0HZo0/img.png" data-lightbox="lightbox" data-alt="사진 출처 : C언어본색-박정민"><img src="https://blog.kakaocdn.net/dn/cQ8Sm7/btseda8ML1R/mtYZKMxBX2k54JwJe0HZo0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcQ8Sm7%2Fbtseda8ML1R%2FmtYZKMxBX2k54JwJe0HZo0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" width="737" height="297" data-origin-width="541" data-origin-height="218"></span><figcaption>사진 출처 : C언어본색-박정민</figcaption>
</figure>
<p></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">하나도 이해가 안된다면 그냥 외우면된다.</p>
<p data-ke-size="size16"><span style="background-color: #f3c000;">1차원 배열에서는 값을 가리켰던 녀석들이 2차원 배열에서는 주소를 가리키는 것이다</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">1차원 배열과 동일하게 2차원 배열도 포인터를 써서 똑같이 쓸 수 있지 않을까? 생각할 수있지만 아래처럼 코드를 짜면 에러가 난다. int *p는 1차원 포인터 변수이므로 2차원 배열을 저장해도 1차원처럼 작동되기 때문이다.</p>
<p data-ke-size="size16">따라서 이 경우에 필요한 것이 바로 배열 포인터이다.</p>
<pre id="code_1683431231724" class="csharp" data-ke-language="csharp" data-ke-type="codeblock"><code class="hljs"><span class="hljs-meta">#include &lt;stdio.h&gt;</span>

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> {
<span class="hljs-built_in">int</span> array[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = { <span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>,<span class="hljs-number">60</span> };
<span class="hljs-built_in">int</span>\* p = array;
printf(<span class="hljs-string">"%d\n"</span>,p[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

}</code></pre>

<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">2-1.배열 포인터</p>
<p data-ke-size="size16">배열 포인터는 배열을 가리키는 포인터 변수이다.</p>
<p data-ke-size="size16">배열 포인터는 다음과 같이 선언한다.</p>
<p></p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="93" data-origin-height="56"><span data-url="https://blog.kakaocdn.net/dn/bCcBfm/btsd0S9OkX4/WTimVlcHp7OQOmZYKpGvb1/img.png" data-lightbox="lightbox"><img src="https://blog.kakaocdn.net/dn/bCcBfm/btsd0S9OkX4/WTimVlcHp7OQOmZYKpGvb1/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbCcBfm%2Fbtsd0S9OkX4%2FWTimVlcHp7OQOmZYKpGvb1%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" width="425" height="256" data-origin-width="93" data-origin-height="56"></span></figure>
<p></p>
<p data-ke-size="size16">앞에 int는 자료형이고 (*p)는 배열 포인터 변수 이름이고 [3]은 열 길이이다</p>
<p data-ke-size="size16">이렇게 배열포인터로 선언을 하면 2차원 배열처럼 포인터도 접근할 수 있게 된다</p>
<pre id="code_1683431701020" class="csharp" data-ke-language="csharp" data-ke-type="codeblock"><code class="hljs"><span class="hljs-meta">#include &lt;stdio.h&gt;</span>

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> {
<span class="hljs-built_in">int</span> array[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = { <span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>,<span class="hljs-number">60</span> };
<span class="hljs-built_in">int</span>(\* p)[<span class="hljs-number">3</span>] = array; <span class="hljs-comment">//포인터 변수에 배열의 시작 주소를 저장</span>
printf(<span class="hljs-string">"%d\n"</span>, array[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);
printf(<span class="hljs-string">"%d\n"</span>,p[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

}</code></pre>

<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">2-2 포인터 배열</p>
<p data-ke-size="size16">주소를 저장하는 배열</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">포인터 배열은 다음과 같이 선언한다</p>
<p></p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="110" data-origin-height="34"><span data-url="https://blog.kakaocdn.net/dn/byfilY/btsd5Y8Zqlw/kW1SVw5KKMVnK1kLhZsSx0/img.png" data-lightbox="lightbox"><img src="https://blog.kakaocdn.net/dn/byfilY/btsd5Y8Zqlw/kW1SVw5KKMVnK1kLhZsSx0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbyfilY%2Fbtsd5Y8Zqlw%2FkW1SVw5KKMVnK1kLhZsSx0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" width="427" height="132" data-origin-width="110" data-origin-height="34"></span></figure>
<p></p>
<p data-ke-size="size16">앞에 int*는 자료형이고 pointer는 포인터배열 변수 이름이고 [3]은 배열 길이이다</p>
<p></p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="546" data-origin-height="119"><span data-url="https://blog.kakaocdn.net/dn/beEfSr/btseh9hukU5/LckyTxQonEytRLFggGNvPk/img.png" data-lightbox="lightbox"><img src="https://blog.kakaocdn.net/dn/beEfSr/btseh9hukU5/LckyTxQonEytRLFggGNvPk/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbeEfSr%2Fbtseh9hukU5%2FLckyTxQonEytRLFggGNvPk%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" width="574" height="125" data-origin-width="546" data-origin-height="119"></span></figure>
<p></p>
<pre id="code_1683435996581" class="csharp" data-ke-language="csharp" data-ke-type="codeblock"><code class="hljs"><span class="hljs-meta">#include &lt;stdio.h&gt;</span>

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> {
<span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>, c = <span class="hljs-number">30</span>;
<span class="hljs-built_in">int</span>* p[<span class="hljs-number">3</span>] = {&amp;a,&amp;b,&amp;c};
printf(<span class="hljs-string">"%d\n"</span>, *p[<span class="hljs-number">0</span>]);
printf(<span class="hljs-string">"%d\n"</span>, *p[<span class="hljs-number">1</span>]);
printf(<span class="hljs-string">"%d\n"</span>, *p[<span class="hljs-number">2</span>]);
printf(<span class="hljs-string">"%d\n"</span>, **(p+<span class="hljs-number">0</span>));
printf(<span class="hljs-string">"%d\n"</span>, **(p+<span class="hljs-number">1</span>));
printf(<span class="hljs-string">"%d\n"</span>, \*\*(p+<span class="hljs-number">2</span>));

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

}</code></pre>

<p data-ke-size="size16">&nbsp;</p>
<div style="background-color: #fafafa; color: #333333;" data-ke-type="moreLess" data-text-more="정답보기" data-text-less="접기"><a class="btn-toggle-moreless">정답보기</a>
<div class="moreless-content">
<p data-ke-size="size16">p[0]에 주소가 들어있으니 *p[0]은 그 주소의 값 따라서 10</p>
<p data-ke-size="size16">나머지도 마찬가지</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">p는 배열의 이름이니 배열의 시작주소인데 +0으로 p의 0번째 요소가 선택되고 0번째요소의 값의 값이니 10이 된다</p>
<pre id="code_1683436136205" class="csharp" data-ke-language="csharp" data-ke-type="codeblock"><code class="hljs"><span class="hljs-meta">#include &lt;stdio.h&gt;</span>

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> {
<span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>, c = <span class="hljs-number">30</span>;
<span class="hljs-built_in">int</span>* p[<span class="hljs-number">3</span>] = {&amp;a,&amp;b,&amp;c};
printf(<span class="hljs-string">"%d\n"</span>, *p[<span class="hljs-number">0</span>]); <span class="hljs-comment">//10</span>
printf(<span class="hljs-string">"%d\n"</span>, *p[<span class="hljs-number">1</span>]); <span class="hljs-comment">//20</span>
printf(<span class="hljs-string">"%d\n"</span>, *p[<span class="hljs-number">2</span>]); <span class="hljs-comment">//30</span>
printf(<span class="hljs-string">"%d\n"</span>, **(p+<span class="hljs-number">0</span>)); <span class="hljs-comment">//10</span>
printf(<span class="hljs-string">"%d\n"</span>, **(p+<span class="hljs-number">1</span>)); <span class="hljs-comment">//20</span>
printf(<span class="hljs-string">"%d\n"</span>, \*\*(p+<span class="hljs-number">2</span>)); <span class="hljs-comment">//30</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

}</code></pre>

</div>
</div>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3">
<p style="color: #333333; text-align: start;" data-ke-size="size16"><span style="color: #000000;">3. 포인터와 문자 배열</span></p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">문자배열은 그냥 1차원 배열과 포인터 개념과 동일하다</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">&nbsp;</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">아래 예문을 보자.</p>
<pre id="code_1683436723414" class="csharp" data-ke-language="csharp" data-ke-type="codeblock"><code class="hljs"><span class="hljs-meta">#include &lt;stdio.h&gt;</span>

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> {
<span class="hljs-built_in">char</span> array[<span class="hljs-number">3</span>] = { <span class="hljs-string">'A'</span>,<span class="hljs-string">'B'</span>,<span class="hljs-string">'C'</span>};
<span class="hljs-built_in">char</span>* p = array; <span class="hljs-comment">//포인터 변수에 배열의 시작 주소를 저장</span>
printf(<span class="hljs-string">"%x %x %x \n"</span>, array, array + <span class="hljs-number">0</span>, &amp;array[<span class="hljs-number">0</span>]); <span class="hljs-comment">//배열 0번째 요소의 주소 출력</span>
printf(<span class="hljs-string">"%c %c %c \n"</span>, *array, _(array + <span class="hljs-number">0</span>), _&amp;array[<span class="hljs-number">0</span>]); <span class="hljs-comment">//뱌욜 0번째 요소의 값 A 출력</span>

    printf(<span class="hljs-string">"%x %x %x \n"</span>, p, p + <span class="hljs-number">0</span>, &amp;p[<span class="hljs-number">0</span>]); <span class="hljs-comment">//배열 0번째 요소의 주소 출력</span>
    printf(<span class="hljs-string">"%c %c %c \n"</span>, *p, *(p + <span class="hljs-number">0</span>), *&amp;p[<span class="hljs-number">0</span>]); <span class="hljs-comment">//배열 0번째 요소의 값 A 출력</span>

}</code></pre>

<p style="color: #333333; text-align: start;" data-ke-size="size16">&nbsp;</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16"><span style="background-color: #f3c000;">다 필요없고 위 같은 경우 포인터변수 p랑 array랑 똑같다고 생각해주면 된다</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3">
<p style="color: #333333; text-align: start;" data-ke-size="size16">&nbsp;</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16"><span style="color: #000000;">4. 포인터와 문자열 배열</span></p>
<p style="color: #333333; text-align: start;" data-ke-size="size16"><span style="color: #000000;">C언어에서 문자열이란 큰 따옴표 내에 포함된 하나 이상의 문자를 의미하며 문자열의 맨 끝에는 문자열의 끝을 알리는 종료 문자 '\0'이 삽입되어 있으며 이런 종료 문자를 널(Null) 문자라 한다</span><span style="color: #000000;"></span></p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="color: #000000;">문자열은 문자들이 메모리 공간에 연속적으로 저장되어 있어서 보통 주소로 관리되며 문자열을 출력할 때는 서식 문자 %s를 쓴다</span><span style="color: #000000;">문자열은 문자들의 집합이므로 문자의 배열이라고 생각할 수 있다</span></p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="color: #000000;">아래 결과를 예상 해보자.</span></p>
<pre id="code_1683437502453" class="csharp" data-ke-language="csharp" data-ke-type="codeblock"><code class="hljs"><span class="hljs-meta">#include &lt;stdio.h&gt;</span>

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> {
<span class="hljs-built_in">char</span> array[<span class="hljs-number">4</span>] = <span class="hljs-string">"ABC"</span>;
printf(<span class="hljs-string">"%c%c%c\n"</span>, array[<span class="hljs-number">0</span>], array[<span class="hljs-number">1</span>], array[<span class="hljs-number">2</span>]);
printf(<span class="hljs-string">"%s"</span>, array);
printf(<span class="hljs-string">"%d %d %d\n"</span>, array[<span class="hljs-number">0</span>], array[<span class="hljs-number">1</span>], array[<span class="hljs-number">2</span>]);
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<div style="background-color: #fafafa; color: #333333;" data-ke-type="moreLess" data-text-more="정답보기" data-text-less="접기"><a class="btn-toggle-moreless">정답보기</a>
<div class="moreless-content">
<p data-ke-size="size16">A를 %d로 출력하면 A의 아스키코드인 65가 출력된다</p>
<pre id="code_1683437583002" class="csharp" data-ke-language="csharp" data-ke-type="codeblock"><code class="hljs"><span class="hljs-meta">#include &lt;stdio.h&gt;</span>

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> {
<span class="hljs-built_in">char</span> array[<span class="hljs-number">4</span>] = <span class="hljs-string">"ABC"</span>;
printf(<span class="hljs-string">"%c%c%c\n"</span>, array[<span class="hljs-number">0</span>], array[<span class="hljs-number">1</span>], array[<span class="hljs-number">2</span>]); <span class="hljs-comment">//ABC 출력</span>
printf(<span class="hljs-string">"%s\n"</span>, array); <span class="hljs-comment">//ABC 출력</span>
printf(<span class="hljs-string">"%d %d %d\n"</span>, array[<span class="hljs-number">0</span>], array[<span class="hljs-number">1</span>], array[<span class="hljs-number">2</span>]); <span class="hljs-comment">//65 66 67 출력</span>
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

</div>
</div>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">다음 결과도 예상해보자.</p>
<pre id="code_1683437863317" class="csharp" data-ke-language="csharp" data-ke-type="codeblock"><code class="hljs"><span class="hljs-meta">#include &lt;stdio.h&gt;</span>

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> {
<span class="hljs-built_in">char</span> array[<span class="hljs-number">4</span>] = <span class="hljs-string">"ABC"</span>;
printf(<span class="hljs-string">"%s\n"</span>, array);
printf(<span class="hljs-string">"%s\n"</span>, array+<span class="hljs-number">1</span>);
printf(<span class="hljs-string">"%s\n"</span>, array+<span class="hljs-number">2</span>);
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<div style="background-color: #fafafa; color: #333333;" data-ke-type="moreLess" data-text-more="정답보기" data-text-less="접기"><a class="btn-toggle-moreless">정답보기</a>
<div class="moreless-content">
<p data-ke-size="size16">array일때는 전체를 가리켜서 ABC가 출력</p>
<p data-ke-size="size16">array+1일때는 arr[1]번째 시작주소를 가리켜서 BC</p>
<p data-ke-size="size16">array+2일때는 array[2]번째 시작주소를 가리켜서 C</p>
<figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="422" data-origin-height="119"><span data-url="https://blog.kakaocdn.net/dn/cLCXWQ/btsd3fctuoU/ZIX6rag3CKqzbqZGtID6P1/img.png" data-lightbox="lightbox"><img src="https://blog.kakaocdn.net/dn/cLCXWQ/btsd3fctuoU/ZIX6rag3CKqzbqZGtID6P1/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcLCXWQ%2Fbtsd3fctuoU%2FZIX6rag3CKqzbqZGtID6P1%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="422" data-origin-height="119"></span></figure>

<pre id="code_1683437887925" class="csharp" data-ke-language="csharp" data-ke-type="codeblock"><code class="hljs"><span class="hljs-meta">#include &lt;stdio.h&gt;</span>

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> {
	<span class="hljs-built_in">char</span> array[<span class="hljs-number">4</span>] = <span class="hljs-string">"ABC"</span>;
	printf(<span class="hljs-string">"%s\n"</span>, array);  <span class="hljs-comment">//ABC 출력</span>
	printf(<span class="hljs-string">"%s\n"</span>, array+<span class="hljs-number">1</span>); <span class="hljs-comment">//BC 출력</span>
	printf(<span class="hljs-string">"%s\n"</span>, array+<span class="hljs-number">2</span>);  <span class="hljs-comment">//C 출력</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</div>
</div>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">이런 문자열을 배열이 아니라 포인터로 바꾸면 아래와 같다</p>
<pre id="code_1683438457302" class="csharp" data-ke-language="csharp" data-ke-type="codeblock"><code class="hljs"><span class="hljs-meta">#include &lt;stdio.h&gt;</span>

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> {
<span class="hljs-built_in">char</span> array[<span class="hljs-number">4</span>] = <span class="hljs-string">"ABC"</span>; <span class="hljs-comment">//배열 방식</span>
printf(<span class="hljs-string">"%s\n"</span>, array);
printf(<span class="hljs-string">"%s\n"</span>, array+<span class="hljs-number">1</span>);
printf(<span class="hljs-string">"%s\n"</span>, array+<span class="hljs-number">2</span>);

    <span class="hljs-built_in">char</span>* p = <span class="hljs-string">"ABC"</span>;  <span class="hljs-comment">//포인터방식</span>
    printf(<span class="hljs-string">"%s\n"</span>, p);
    printf(<span class="hljs-string">"%s\n"</span>, p + <span class="hljs-number">1</span>);
    printf(<span class="hljs-string">"%s\n"</span>, p + <span class="hljs-number">2</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

}</code></pre>

<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3">
<p data-ke-size="size16"><span style="color: #000000; text-align: start;">5. 함수 심화(Call my Value, Call my Reference)</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="color: #000000;">함수에서 이때 까지 사용했던 방식이 Call my Value인데 그것은 </span><span style="color: #000000;">값을 복사하는 방식이다.</span></p>
<pre id="code_1683439110958" class="csharp" data-ke-language="csharp" data-ke-type="codeblock"><code class="hljs"><span class="hljs-meta">#include &lt;stdio.h&gt;</span>
<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">func</span>(<span class="hljs-params"><span class="hljs-built_in">int</span></span>)</span>;
<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> {
	<span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;
	printf(<span class="hljs-string">"%d\n"</span>,func(a));  <span class="hljs-comment">//11출력</span>
    printf(<span class="hljs-string">"%d\n"</span>,a);  <span class="hljs-comment">//10출력</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">func</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a</span>)</span> {
a = a + <span class="hljs-number">1</span>;
<span class="hljs-keyword">return</span> a;
}</code></pre>

<p style="color: #333333; text-align: start;" data-ke-size="size16">&nbsp;</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">main 함수에서 변수 a를 선언하면서 초기화 한 후 a변수를 인수로 전달하면서 매개변수 a로 값이 복사된다</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">값을 복사하는 방식으로 main()함수의 지역변수 a 값 변동에는 영향을 미치지 않는다</p>
<p></p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="1659" data-origin-height="735"><span data-url="https://blog.kakaocdn.net/dn/AEkaK/btsec9PDTfw/SUDTdsUvXsisNFWdYXx5PK/img.png" data-lightbox="lightbox"><img src="https://blog.kakaocdn.net/dn/AEkaK/btsec9PDTfw/SUDTdsUvXsisNFWdYXx5PK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FAEkaK%2Fbtsec9PDTfw%2FSUDTdsUvXsisNFWdYXx5PK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="1659" data-origin-height="735"></span></figure>
<p></p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">다음은 새로 배우게 될 Call by Reference(주소 참조) 방식이다</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">주소를 인수로 받아서 값을 바꾸기 때문에 main()함수의 지역변수 a에도 영향을 미친다</p>
<pre id="code_1683440238782" class="csharp" data-ke-language="csharp" data-ke-type="codeblock"><code class="hljs"><span class="hljs-meta">#include &lt;stdio.h&gt;</span>
<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">func</span>(<span class="hljs-params"><span class="hljs-built_in">int</span></span>)</span>;
<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> {
	<span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;
	printf(<span class="hljs-string">"%d\n"</span>,func(&amp;a)); <span class="hljs-comment">//11 출력</span>
	printf(<span class="hljs-string">"%d"</span>, a);  <span class="hljs-comment">//11 출력</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">func</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>* a</span>)</span> {
*a = *a + <span class="hljs-number">1</span>;
<span class="hljs-keyword">return</span> *a;
}</code></pre>

<p></p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="1710" data-origin-height="674"><span data-url="https://blog.kakaocdn.net/dn/TtZtU/btsd6tVz5hR/kK6PoC6vyh13HpWhnQ3kV1/img.png" data-lightbox="lightbox"><img src="https://blog.kakaocdn.net/dn/TtZtU/btsd6tVz5hR/kK6PoC6vyh13HpWhnQ3kV1/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FTtZtU%2Fbtsd6tVz5hR%2FkK6PoC6vyh13HpWhnQ3kV1%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="1710" data-origin-height="674"></span></figure>
<p></p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">int func(int* a)인 이유는 주소를 전달받기 때문이다</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">쉽게 생각해서 포인터변수를 선언할 때 int *p=&amp;a; 이런식으로 선언하는 것을 생각하면 된다</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">주소를 받기 때문에 함수의 매개변수 형태가 포인터변수가 되는 것이다</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3">
<p style="color: #333333; text-align: start;" data-ke-size="size16">6. 구조체</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">하나 이상의 변수를 묶어 그룹화하는 사용자 정의 자료형이다</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">배열이 같은 자료형만 담을 수 있다면 구조체는 다른 자료형도 담을 수 있다</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">&nbsp;</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">아래와 같은 형식으로 구조체를 정의한다</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">struct : 구조체 키워드</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">student : 구조체 이름</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">&nbsp;</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">int score, char name은 구조체 멤버 변수</p>
<pre id="code_1683441356582" class="csharp" data-ke-language="csharp" data-ke-type="codeblock"><code class="hljs"><span class="hljs-keyword">struct</span> student
{
	<span class="hljs-built_in">int</span> score;
	<span class="hljs-built_in">char</span> name;
};</code></pre>
<p data-ke-size="size16">구조체 정의를 하고 구조체 변수 선언을 동시에 하는 방법은 아래와 같다.</p>
<pre id="code_1683441542158" class="csharp" data-ke-language="csharp" data-ke-type="codeblock"><code class="hljs"><span class="hljs-keyword">struct</span> student
{
	<span class="hljs-built_in">int</span> score;
	<span class="hljs-built_in">char</span> name;
}p1, p2, p3;</code></pre>
<p></p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="319" data-origin-height="471"><span data-url="https://blog.kakaocdn.net/dn/dUK1Du/btsdZZazp4D/CoEELuRuYmS9uaNCedrjf0/img.png" data-lightbox="lightbox"><img src="https://blog.kakaocdn.net/dn/dUK1Du/btsdZZazp4D/CoEELuRuYmS9uaNCedrjf0/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdUK1Du%2FbtsdZZazp4D%2FCoEELuRuYmS9uaNCedrjf0%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="319" data-origin-height="471"></span></figure>
<p></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">따로 선언하는 방식은 아래와 같다.</p>
<pre id="code_1683441789430" class="csharp" data-ke-language="csharp" data-ke-type="codeblock"><code class="hljs"><span class="hljs-meta">#include&lt;stdio.h&gt;</span>
<span class="hljs-keyword">struct</span> student
{
	<span class="hljs-built_in">int</span> score;
	<span class="hljs-built_in">char</span> name;
};

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span>{
<span class="hljs-keyword">struct</span> student p1, p2, p3;

<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">구조체 변수에 .(도트 연산자)를 이용하면 각 변수별 멤버변수에 접근할 수 있다</p>
<p data-ke-size="size16">p1.score이라고 하면 p1의 score에 접근이 가능해지며</p>
<p data-ke-size="size16">p1.score=30; 이라고 하면 p1.score 자리에 30이 저장된다</p>
<p></p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="365" data-origin-height="194"><span data-url="https://blog.kakaocdn.net/dn/cWkPrH/btsd6tBjY3X/hJDmih1Jg8egPlyN7Z2RfK/img.png" data-lightbox="lightbox"><img src="https://blog.kakaocdn.net/dn/cWkPrH/btsd6tBjY3X/hJDmih1Jg8egPlyN7Z2RfK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcWkPrH%2Fbtsd6tBjY3X%2FhJDmih1Jg8egPlyN7Z2RfK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="365" data-origin-height="194"></span></figure>
<p></p>
<pre id="code_1683441972942" class="csharp" data-ke-language="csharp" data-ke-type="codeblock"><code class="hljs"><span class="hljs-meta">#include&lt;stdio.h&gt;</span>
<span class="hljs-keyword">struct</span> student
{
	<span class="hljs-built_in">int</span> score;
	<span class="hljs-built_in">char</span> name;
};

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span>{
<span class="hljs-keyword">struct</span> student p1, p2, p3;
p1.score = <span class="hljs-number">30</span>;
printf(<span class="hljs-string">"%d"</span>, p1.score); <span class="hljs-comment">//30출력</span>

<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">6-1 구조체와 배열</p>
<p data-ke-size="size16">멤버변수로 배열도 사용 가능하다</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">학생 수가 많아지면 구조체 변수 p1,p2,p3가 무한히 많이 필요할 텐데 이런 문제를 해결하기 위해 구조체 변수를 배열로 사용하면 된다</p>
<pre id="code_1683444699687" class="csharp" data-ke-language="csharp" data-ke-type="codeblock"><code class="hljs"><span class="hljs-meta">#include&lt;stdio.h&gt;</span>
<span class="hljs-keyword">struct</span> student {
	<span class="hljs-built_in">char</span> no[<span class="hljs-number">10</span>];
	<span class="hljs-built_in">char</span> name[<span class="hljs-number">20</span>];
	<span class="hljs-built_in">double</span> math;
	<span class="hljs-built_in">double</span> english;
};

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span>{
<span class="hljs-keyword">struct</span> student stu[<span class="hljs-number">3</span>] = {
{<span class="hljs-string">"12345"</span>,<span class="hljs-string">"Lee"</span>,<span class="hljs-number">90</span>,<span class="hljs-number">90</span>},
{<span class="hljs-string">"12346"</span>,<span class="hljs-string">"KIM"</span>,<span class="hljs-number">80</span>,<span class="hljs-number">70</span>},
{<span class="hljs-string">"12347"</span>,<span class="hljs-string">"Park"</span>,<span class="hljs-number">50</span>,<span class="hljs-number">100</span>}
};

<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p data-ke-size="size16">&nbsp;</p>
<p></p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-width="1596" data-origin-height="345"><span data-url="https://blog.kakaocdn.net/dn/qBzeC/btsedcZZyXc/KIrSpWbAp3x4mCG4hYlwMK/img.png" data-lightbox="lightbox"><img src="https://blog.kakaocdn.net/dn/qBzeC/btsedcZZyXc/KIrSpWbAp3x4mCG4hYlwMK/img.png" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FqBzeC%2FbtsedcZZyXc%2FKIrSpWbAp3x4mCG4hYlwMK%2Fimg.png" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" data-origin-width="1596" data-origin-height="345"></span></figure>
<p></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">6-2 구조체와 포인터</p>
<pre id="code_1683445572079" class="csharp" data-ke-language="csharp" data-ke-type="codeblock"><code class="hljs"><span class="hljs-meta">#include&lt;stdio.h&gt;</span>
<span class="hljs-keyword">struct</span> p {
	<span class="hljs-built_in">int</span>* x;
	<span class="hljs-built_in">int</span>* y;
};

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span>{
<span class="hljs-built_in">int</span> a = <span class="hljs-number">5</span>;
<span class="hljs-built_in">int</span> b = <span class="hljs-number">4</span>;
<span class="hljs-keyword">struct</span> p p1;
p1.x = &amp;a;
p1.y = &amp;b;

    printf(<span class="hljs-string">"%d %d\n"</span>, a, b);
    printf(<span class="hljs-string">"%d %d\n"</span>, *p1.x, *p1.y);

<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p data-ke-size="size16">출력결과를 예상해보자</p>
<div style="background-color: #fafafa; color: #333333;" data-ke-type="moreLess" data-text-more="정답보기" data-text-less="접기"><a class="btn-toggle-moreless">정답보기</a>
<div class="moreless-content">
<p style="color: #333333; text-align: start;" data-ke-size="size16">5 4</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">5 4</p>
</div>
</div>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">구초제 변수로 포인터를 사용할 수 도 있다</p>
<p data-ke-size="size16">구조체 변수로 포인터를 사용한다는 것은 구조체 변수에 간접 접근할 수 있다는 의미이다</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">(*p)를 한 이유는 .연산자가 *연산자보다 우선순위가 높아 *p를 먼저 연산하기 위함이다</p>
<p data-ke-size="size16">p는 포인터변수인데 p가 구조체 변수 stu의 주소를 담고 있으므로 *p는 stu의 값을 가리킨다</p>
<p data-ke-size="size16">-&gt;연산자는 포인터 변수만으로 구조체의 멤버 변수에 접근할 때 사용한다</p>
<pre id="code_1683446193030" class="csharp" data-ke-language="csharp" data-ke-type="codeblock"><code class="hljs"><span class="hljs-meta">#include&lt;stdio.h&gt;</span>
<span class="hljs-keyword">struct</span> student {
	<span class="hljs-built_in">char</span> no[<span class="hljs-number">10</span>];
	<span class="hljs-built_in">char</span> name[<span class="hljs-number">20</span>];
	<span class="hljs-built_in">double</span> total;
};

<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span>{
<span class="hljs-keyword">struct</span> student stu = {<span class="hljs-string">"12345"</span>,<span class="hljs-string">"KIM"</span>,<span class="hljs-number">20</span>};
<span class="hljs-keyword">struct</span> student\* p = &amp;stu;

    printf(<span class="hljs-string">"%s %s %lf\n"</span>, (*p).no, (*p).name, (*p).total); <span class="hljs-comment">//12345 KIM 20 출력</span>
    printf(<span class="hljs-string">"%s %s %lf\n"</span>, p-&gt;no, p-&gt;name, p-&gt;total);<span class="hljs-comment">//12345 KIM 20 출력</span>

<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p style="color: #333333; text-align: start;" data-ke-size="size16">&nbsp;</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">&nbsp;</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">&nbsp;</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16"><a style="color: #0070d1; text-align: start;" href="https://complainrevolutionist.tistory.com/83">[정보처리기사/예상문제] - 2023 정보처리기사 실기 예상 문제 모음</a></p>
<p style="background-color: #ffffff; color: #000000; text-align: start;" data-ke-size="size16"><a style="color: #0070d1;" href="https://complainrevolutionist.tistory.com/38">C언어 기출문제 모음</a></p>
<p data-ke-size="size16"><a style="color: #006dd7;" href="https://complainrevolutionist.tistory.com/132">비전공자용 C언어 요약 1탄</a></p>
<p style="color: #333333; text-align: start;" data-ke-size="size16"><span style="color: #006dd7;"><a style="color: #006dd7;" href="https://complainrevolutionist.tistory.com/133">비전공자용 C언어 요약 2탄(조건문, 반복문, 배열)</a></span></p>
<p style="color: #333333; text-align: start;" data-ke-size="size16"><span style="color: #006dd7;"><a style="color: #006dd7;" href="https://complainrevolutionist.tistory.com/138">비전공자용 C언어 요약 3탄(함수, 포인터)</a></span></p>
<p style="color: #333333; text-align: start;" data-ke-size="size16"><a style="color: #0070d1;" href="https://complainrevolutionist.tistory.com/139">비전공자용 C언어 요약 4탄(포인터 심화, 구조체)</a></p></div>
